{"version":3,"file":"lrud.min.js","names":["focusableSelector","LRUD_CONTAINER","ignoreSelector","DESTINATIONS_ATTRIBUTE","DATA_BLOCK_EXIT_ATTRIBUTE","DATA_AUTOFOCUS_ATTRIBUTE","DATA_FOCUS_ATTRIBUTE","_left","_right","_up","_down","_keyMap","_noValidDestinationCallback","elem","hasAutoFocus","console","warn","setConfig","exports","config","keyMap","noValidDestinationCallback","isStrictDescendant","child","ancestor","contains","isContainer","node","_node$classList","classList","isContainerWithAutofocus","_node$classList2","getAttribute","isContainerTVFocusable","_node$classList3","tabIndex","toArray","nodeList","Array","prototype","slice","call","getParentContainerWithBlockedExits","parent","parentElement","blockExits","tagName","length","getParentContainer","getFocusableParentContainer","_elem$parentElement","getFirstFocusableElement","container","focusable","parentHasAutofocus","focusables","querySelectorAll","firstFocusable","getFocusables","scope","_focusables2","ignoredElements","filter","some","ignored","parseInt","_focusables","childrenToIgnore","Set","forEach","allChildren","add","size","_focusables3","has","getDefaultFocus","exitDir","nextFocus","candidates","getAllFocusables","candidate","candidateIsContainer","findDestinationOrAutofocus","concat","getMidpointForEdge","rect","dir","x","left","y","top","bottom","right","getNearestPoint","point","getDistanceBetweenPoints","a","b","Math","sqrt","pow","isBelow","isRight","isValidCandidate","entryRect","exitPoint","entryWeighting","width","height","weightedEntryPoint","sortValidCandidates","exitRect","getBoundingClientRect","EPSILON","AXIS_OVERLAP_THRESHOLD","getAxisOverlapRatio","originRect","overlap","max","min","allowedOverlap","parseFloat","map","idx","nearestPoint","distance","axisOverlapRatio","axisOverlap","alignmentDelta","abs","sort","distanceDiff","alignmentDiff","_ref","getPreferredDestination","parentContainer","destinations","candidateIDs","split","newFocus","_iterator","_createForOfIteratorHelper","_step","s","n","done","candidateID","value","document","getElementById","err","e","f","undefined","candidateContainer","domOrderAsDefault","candidateContainerFocusables","getNextFromCandidates","focusableCandidates","_originsBlockedInfo$b","originsBlockedInfo","exitsBlocked","includes","_iterator2","_step2","_getFocusableParentCo","updateAncestorsAutoFocus","current","setAttribute","id","getNextFocus","keyOrKeyCode","querySelector","body"],"sources":["lrud.js"],"sourcesContent":["/**\n * LRUD: Spatial Edition\n *\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *  @@@@@@      '@@@@@@@@@   @@@@@@      '@@@@@@@@@   @@@@@@@@      '@@@@@@@\n *  @@@@@@  @@.   @@@@@@@@   @@@@@@  @@.    @@@@@@@   @@@@@     @@@@.   @@@@\n *  @@@@@@  @@@@  @@@@@@@@   @@@@@@  @@@@   @@@@@@@   @@@@   @@@@@@@@@@@@@@@\n *  @@@@@@        @@@@@@@@   @@@@@@        @@@@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@.  @@@@@@   @@@@@@  @@@@@.  @@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@   @@@@@@   @@@@@@  @@@@@   @@@@@@   @@@@    @@@@@@@@/ @@@@\n *  @@@@@@        /@@@@@@@   @@@@@@        /@@@@@@@   @@@@@@\\,         @@@@@\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *\n * Copyright (C) 2023 BBC.\n */\n\n// Any \"interactive content\" https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Interactive_content\nconst focusableSelector = '[tabindex], a, input, button';\nconst LRUD_CONTAINER = 'lrud-container';\nconst ignoreSelector = '.lrud-ignore, [disabled]';\nconst DESTINATIONS_ATTRIBUTE = 'data-destinations';\nconst DATA_BLOCK_EXIT_ATTRIBUTE = 'data-block-exit';\nconst DATA_AUTOFOCUS_ATTRIBUTE = 'data-autofocus';\nconst DATA_FOCUS_ATTRIBUTE = 'data-focus';\n// const PRIORITISE_CHILDREN_ATTRIBUTE = 'data-lrud-prioritise-children'; // Only set when data-block-exit are set\n\n/**\n * This is how the React Native Web TV props are mapped here:\n *\n * 1. TVFocusGuideView.container={true} -> .lrud-container : This is the main attribute that sets the element as a container for the LRUD logic.\n *    .lrud-container can be of two types:\n *    a. With tabindex=0: A \"focusable container\" with atleast one of data-autofocus=\"true\" or data-destinations\n *        This container will be able to participate in LRUD logic and can be focused as a whole to determined which child needs to get focus.\n *        A focusable container may still have data-block-exit attributes to block focus movement in certain directions.\n *    b. With tabindex=-1: A \"non-focusable container\" with none of the valid (or true) data-autofocus or data-destinations, But could have a valid data-block-exit.\n *        This container will not participate in the LRUD focasibility logic but it will be used for trapping focus in the specified direction.\n *\n * 2. TVFocusGuideView.focusable={false} -> sets .lrud-ignore : Ignores .lrud-container and it's children for LRUD logic\n * 3. TVFocusGuideView.autoFocus={true} -> data-autofocus attribute is 'true'/'false'. The attribute controls whether\n *    data-focus in parent containers should be applied or not. And stores last focused child in data-focus attribute.\n * 4. TVFocusGuideView.destinations=[\"id1\", \"id2\"] -> data-destinations=\"id1 id2\": These ids are from\n *    id assigned to each of the destination elements. This overrides data-focus logic (whether present or not).\n * 5. TVFocusGuideView.trapFocusUp={true} -> data-block-exit=\"up\"\n * 6. TVFocusGuideView.trapFocusDown={true} -> data-block-exit=\"down\"\n * 7. TVFocusGuideView.trapFocusLeft={true} -> data-block-exit=\"left\"\n * 8. TVFocusGuideView.trapFocusRight={true} -> data-block-exit=\"right\"\n *\n * Rules:\n * - For the first time focus:\n *  1. Default rule is to focus the first focusable element in the DOM tree order.\n *  2. If that element is in a .lrud-container and that container has data-autofocus=\"true\", then:\n *   a. If that container has data-destinations, first valid element from that list is focused.\n *   b. Else if that container has data-focus set to a valid element id, that element is focused.\n *   c. Else first focusable element as per LRUD logic is focused: On Android TV this seems to be the one closest to top-left corner of the container/window.\n *\n * - Candidates selection on directional navigation:\n *  1. The selection is influenced by the direction of the navigation (up, down, left, right).\n *  2. Candidates are selected based on their proximity to the currently focused element.\n *  3. All elements with tabindex>=0 are considered as candidates by default (with some exceptions as described below).\n *  4. The candidate search is container within the scope first (if provided).\n *  3. All elements with tabindex=\"-1\" are ignored unless they are .lrud-container elements (which requires special logic as described below).\n *  4. All elements with .lrud-ignore class or disabled attribute are ignored along with their children.\n *  5. If an element is a .lrud-container with data-autofocus=\"true\" or data-destinations (and tabindex=0)\n *     - AND the current focus is NOT inside that container\n *       - the container itself becomes a candidate and it's children are ignored.\n *  6. If an element is a .lrud-container with data-autofocus=\"true\" or data-destinations (and tabindex=0)\n *     - AND the current focus is outside that container\n *       - the container's children as considered as candidates and container itself is ignored.\n *\n * - Focus selection from candidates:\n * 1. From the list of candidates, the one that is closest to the current focus in the requested direction is selected.\n * 2. If the selected candidate is a .lrud-container with data-autofocus=\"true\", the following logic is applied to determine the actual focus:\n *   a. If the container has data-destinations, the first valid element from that list is focused.\n *   b. Else if the container has data-focus set to a valid element id, that element is focused.\n *   c. Else the first focusable element inside the container is focused.\n * 3. If the selected candidate is not a .lrud-container, and does not have data-autofocus=\"true\", the container is returned.\n * 4. If no valid candidate is found, null is returned.\n *\n * This module does not have a state of it's own. It relies on the DOM structure and attributes\n * to determine the next focusable element. It does not manage focus itself. If it successfully finds a new focus element,\n * it returns that element and details if that element is a container with data-autofocus=\"true\".\n * The calling code is responsible for actually setting the focus to that element.\n *\n * - Trap focus logic:\n */\n\nconst _left = 'left', _right = 'right', _up = 'up', _down = 'down';\nlet _keyMap = {\n  4: _left,\n  21: _left,\n  37: _left,\n  214: _left,\n  205: _left,\n  218: _left,\n  5: _right,\n  22: _right,\n  39: _right,\n  213: _right,\n  206: _right,\n  217: _right,\n  29460: _up,\n  19: _up,\n  38: _up,\n  211: _up,\n  203: _up,\n  215: _up,\n  29461: _down,\n  20: _down,\n  40: _down,\n  212: _down,\n  204: _down,\n  216: _down,\n  'ArrowLeft': _left,\n  'ArrowRight': _right,\n  'ArrowUp': _up,\n  'ArrowDown': _down\n};\n\n/**\n * Default callback for when no valid destination is found. Can be overridden by setConfig.\n *\n * @param {elem: HTMLElement} elem\n * @param {boolean} hasAutoFocus\n */\n\nlet _noValidDestinationCallback = (elem, hasAutoFocus) => {\n  console.warn('No valid destination found for LRUD container: ', elem, 'with autofocus: ', hasAutoFocus);\n};\n\nexport const setConfig = (config) => {\n  _keyMap = config.keyMap || _keyMap;\n  _noValidDestinationCallback = config.noValidDestinationCallback || _noValidDestinationCallback;\n};\n\n// const hasDOM = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof Element !== 'undefined';\n\n// // Element.matches() with fallbacks for older browsers\n// const matchesFunction = hasDOM && (window.Element.prototype.matches ||\n//   window.Element.prototype.matchesSelector ||\n//   window.Element.prototype.mozMatchesSelector ||\n//   window.Element.prototype.msMatchesSelector ||\n//   window.Element.prototype.oMatchesSelector) ||\n//   function(s) {\n//     var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n//       i = matches.length;\n//     // eslint-disable-next-line no-empty\n//     while (--i >= 0 && matches.item(i) !== this) {}\n//     return i > -1;\n//   };\n\n// /**\n//  * Element API .matches() with fallbacks\n//  */\n// const matches = (element, selectors) => {\n//   if (!element) {\n//     console.warn('matches() passed with a null element');\n//     return false;\n//   }\n\n//   return matchesFunction.call(element, selectors);\n// };\n\nconst isStrictDescendant = (child, ancestor) => child !== ancestor && ancestor.contains(child);\n\n// check if the node is a container irrespective of whether it's focusable or not\nconst isContainer = (node) => node?.classList?.contains(LRUD_CONTAINER);\n\nconst isContainerWithAutofocus = (node) =>\n  node?.classList?.contains(LRUD_CONTAINER) &&\n  node?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n\n// const isContainerWithDestinations = (node) =>\n//   node?.classList?.contains(LRUD_CONTAINER) &&\n//   node?.getAttribute(DESTINATIONS_ATTRIBUTE)?.length > 0;\n\n// RN Web will make sure that any .lrud-container with valid data-autofocus=\"true\" or data-destinations\n// will always have tabindex=0\nconst isContainerTVFocusable = (node) =>\n  // A tvFocusable is a container with either data-autofocus or data-destinations set\n  node?.classList?.contains(LRUD_CONTAINER) &&\n  node?.tabIndex === 0;\n  // (node?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true' ||\n  //   node?.getAttribute(DESTINATIONS_ATTRIBUTE)?.length > 0);\n\n/**\n * Convert a NodeList to a regular Array\n *\n * @param {NodeList} nodeList The NodeList representation\n * @return {Array|null} The Array representation\n */\nconst toArray = (nodeList) => Array.prototype.slice.call(nodeList);\n\n/**\n * Traverse DOM ancestors until we find a container which has .lrud-container &\n * data-block-exit attribute\n *\n * @param {HTMLElement} elem The element representing the search origin\n * @return {{parent: HTMLElement|null, blockExits: string[]|null}} The parent focus container with block exits or null\n */\nconst getParentContainerWithBlockedExits = (elem) => {\n  const parent = elem?.parentElement;\n  const blockExits = parent?.getAttribute(DATA_BLOCK_EXIT_ATTRIBUTE);\n  if (!parent || parent.tagName === 'BODY') {\n    return { parent: null, blockExits: null };\n  } else if (isContainer(parent) && blockExits?.length > 0) {\n    return { parent, blockExits: blockExits };\n  }\n\n  return getParentContainerWithBlockedExits(parent);\n};\n\n/**\n * Traverse DOM ancestors until we find a container\n *\n * @param {HTMLElement} elem The element representing the search origin\n * @return {HTMLElement|null} The parent focus container or null\n */\nexport const getParentContainer = (elem) => {\n  if (!elem?.parentElement || elem?.parentElement.tagName === 'BODY') {\n    return null;\n  } else if (isContainer(elem.parentElement)) {\n    return elem.parentElement;\n  }\n\n  return getParentContainer(elem.parentElement);\n};\n\n/**\n * Traverse DOM ancestors until we find a focus container\n *\n * @param {HTMLElement} elem The element representing the search origin\n * @return {HTMLElement|null} The parent focus container or null\n */\nexport const getFocusableParentContainer = (elem) => {\n  if (!elem?.parentElement || elem?.parentElement.tagName === 'BODY') {\n    return null;\n  } else if (isContainer(elem.parentElement) && elem?.parentElement?.tabIndex === 0) {\n    return elem.parentElement;\n  }\n\n  return getFocusableParentContainer(elem.parentElement);\n};\n\n/**\n * Get first focusable (non container element) inside a container,\n * or null if none exists\n *\n * @param {HTMLElement} container The container element to search inside\n * @return {HTMLElement|null} The first focusable element or null\n */\nconst getFirstFocusableElement = (container) => {\n  let focusable = { elem: null, parentHasAutofocus: false };\n  if (!container) return focusable;\n\n  const focusables = toArray(container.querySelectorAll(focusableSelector));\n  if (focusables.length > 0) {\n    const firstFocusable = focusables[0];\n    if (!isContainer(firstFocusable)) {\n      focusable.elem = firstFocusable;\n      focusable.parentHasAutofocus = container?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n    }\n    else {\n      return getFirstFocusableElement(firstFocusable);\n    }\n  }\n  return focusable;\n};\n\n/**\n * Get all focusable elements inside `scope`,\n * discounting any that are ignored or inside an ignored container\n *\n * @param {HTMLElement|null} elem The element representing the search origin (currently focused element)\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getFocusables = (elem, scope) => {\n  if (!scope) return [];\n  /**\n   * Get all elements (within scope) that:\n   *  have a tabindex -> remove .lrud-ignore and children ->\n   *  filter all with tabindex=-1\n   *  filter all .lrud-container with focus inside (could be nested containers) ->\n   *  filter all children of .lrud-container with data-autofocus=\"true\" OR data-destinations=[...]\n   */\n\n  const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n  let focusables = toArray(scope.querySelectorAll(focusableSelector))\n    .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n    .filter(node => parseInt(node.getAttribute('tabindex') || '-1', 10) > -1);\n\n  if (elem) {\n    // To remove containers that have focus inside them\n    focusables = focusables?.filter(node => (isContainer(node) && node.contains(elem)) ? false : true);\n  }\n\n  // Create a set of children to ignore from containers with data-autofocus=\"true\" or data-destinations\n  let childrenToIgnore = new Set();\n  focusables?.forEach(node => {\n    if (isContainerTVFocusable(node)) {\n      // add all focusable children to ignore set\n      const allChildren = toArray(node.querySelectorAll(focusableSelector));\n      allChildren.forEach(child => childrenToIgnore.add(child));\n    }\n  });\n\n  // Finally filter out all children that are in the ignore set\n  if (childrenToIgnore.size > 0) {\n    focusables = focusables?.filter(node => !childrenToIgnore.has(node));\n  }\n  return focusables;\n};\n\n/**\n * Get first focusable element as a default focus inside a 'scope'\n *\n * @param {HTMLElement} scope The element to search inside of\n * @param {String} exitDir The direction we exited from the starting element\n * @return {{elem: HTMLElement|null, parentHasAutofocus: boolean}} First focusable HTML Element\n */\nconst getDefaultFocus = (scope, exitDir) => {\n  let nextFocus = {elem: null, parentHasAutofocus: false};\n  const candidates = getAllFocusables(null, scope);\n  if (candidates.length > 0) {\n    let candidate = candidates[0];\n    // First candiate may be a container with autofocus or destinations\n    const candidateIsContainer = isContainer(candidate);\n    if (candidateIsContainer) {\n       nextFocus = findDestinationOrAutofocus(null, exitDir, candidate, false);\n    } else {\n      nextFocus = { elem: candidate, parentHasAutofocus: false };\n    }\n  }\n  return nextFocus;\n};\n\n/**\n * Get all the focusable candidates inside `scope`,\n * including focusable containers\n *\n * @param {HTMLElement|null} elem The element representing the search origin (currently focused element)\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getAllFocusables = (elem, scope) =>\n  // const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n    [\n    // ...toArray(scope.querySelectorAll(focusableContainerSelector))\n      // .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n      // .filter(container => getFocusables(container)?.length > 0),\n    ...getFocusables(elem, scope)\n  ];\n\n/**\n * Get the middle point of a given edge\n *\n * @param {Object} rect An object representing the rectangle\n * @param {String} dir The direction of the edge (left, right, up, down)\n * @return {Point} An object with the X and Y coordinates of the point\n */\nconst getMidpointForEdge = (rect, dir) => {\n  switch (dir) {\n    case 'left':\n      return { x: rect.left, y: (rect.top + rect.bottom) / 2 };\n    case 'right':\n      return { x: rect.right, y: (rect.top + rect.bottom) / 2 };\n    case 'up':\n      return { x: (rect.left + rect.right) / 2, y: rect.top };\n    case 'down':\n      return { x: (rect.left + rect.right) / 2, y: rect.bottom };\n  }\n};\n\n/**\n * Gets the nearest point on `rect` that a line in direction `dir` from `point` would hit\n * If the rect is exactly in direction `dir` then the point will be in a straight line from `point`.\n * Otherwise it will be the nearest corner of the target rect.\n *\n * @param {Point} point The point to start from\n * @param {String} dir The direction to draw the line in\n * @param {Object} rect An object representing the rectangle of the item we're going to\n * @return {Point} An object with the X/Y coordinates of the nearest point\n */\nconst getNearestPoint = (point, dir, rect) => {\n  if (dir === 'left' || dir === 'right') {\n    // When moving horizontally...\n    // The nearest X is always the nearest edge, left or right\n    const x = dir === 'left' ? rect.right : rect.left;\n\n    // If the start point is higher than the rect, nearest Y is the top corner\n    if (point.y < rect.top) return { x, y: rect.top };\n    // If the start point is lower than the rect, nearest Y is the bottom corner\n    if (point.y > rect.bottom) return { x, y: rect.bottom };\n    // Else the nearest Y is aligned with where we started\n    return { x, y: point.y };\n  } else if (dir === 'up' || dir === 'down') {\n    // When moving vertically...\n    // The nearest Y is always the nearest edge, top or bottom\n    const y = dir === 'up' ? rect.bottom : rect.top;\n\n    // If the start point is left-er than the rect, nearest X is the left corner\n    if (point.x < rect.left) return { x: rect.left, y };\n    // If the start point is right-er than the rect, nearest X is the right corner\n    if (point.x > rect.right) return { x: rect.right, y };\n    // Else the nearest X is aligned with where we started\n    return { x: point.x, y };\n  }\n};\n\n/**\n * Get the Pythagorean distance between two points\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {number} Distance from A to B\n */\nconst getDistanceBetweenPoints = (a, b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n\n/**\n * Check if point A is below point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is below b, false otherwise\n */\nconst isBelow = (a, b) => a.y > b.y;\n\n/**\n * Check if point A is to the right of point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is to the right of b, false otherwise\n */\nconst isRight = (a, b) => a.x > b.x;\n\n// /**\n//  * Get blocked exit directions for current node\n//  *\n//  * @param {HTMLElement} originContainer Current focus container\n//  * @param {HTMLElement} candidateContainer Candidate focus container\n//  * @return {string[]} Array of strings representing blocked directions\n//  */\n// const getBlockedExitDirs = (originContainer, candidateContainer) => {\n//   if (!originContainer) {\n//     return [];\n//   }\n\n//   const currentAncestorContainers = collectContainers(originContainer);\n//   const candidateAncestorContainers = collectContainers(candidateContainer);\n\n//   // Find common container for current container and candidate container and\n//   // remove everything above it\n//   for (let i = 0; i < candidateAncestorContainers.length; i++) {\n//     let commonCandidate = candidateAncestorContainers[i];\n\n//     const spliceIndex = currentAncestorContainers.indexOf(commonCandidate);\n\n//     if (spliceIndex > -1) {\n//       currentAncestorContainers.splice(spliceIndex);\n//       break;\n//     }\n//   }\n\n//   return currentAncestorContainers.reduce((acc, cur) => {\n//     const dirs = (cur?.getAttribute(DATA_BLOCK_EXIT_ATTRIBUTE) || '').split(' ');\n\n//     return acc.concat(dirs);\n//   }, []);\n// };\n\n/**\n * Check if the candidate is in the `exitDir` direction from the rect we're leaving,\n * with an overlap allowance of entryWeighting as a percentage of the candidate's width.\n *\n * @param {Object} entryRect An object representing the rectangle of the item we're moving to\n * @param {String} exitDir The direction we're moving in\n * @param {Object} exitPoint The midpoint of the edge we're leaving\n * @param {Float} entryWeighting Percentage of the candidate that is allowed to be behind the target\n * @return {Booelan} true if candidate is in the correct dir, false if not\n */\nconst isValidCandidate = (entryRect, exitDir, exitPoint, entryWeighting) => {\n  if (entryRect.width === 0 && entryRect.height === 0) return false;\n  if (!entryWeighting && entryWeighting != 0) entryWeighting = 0.3;\n\n  const weightedEntryPoint = {\n    x: entryRect.left + (entryRect.width * (exitDir === 'left' ? 1 - entryWeighting : exitDir === 'right' ? entryWeighting : 0.5)),\n    y: entryRect.top + (entryRect.height * (exitDir === 'up' ? 1 - entryWeighting : exitDir === 'down' ? entryWeighting : 0.5))\n  };\n\n  if (\n    exitDir === 'left' && isRight(exitPoint, weightedEntryPoint) ||\n    exitDir === 'right' && isRight(weightedEntryPoint, exitPoint) ||\n    exitDir === 'up' && isBelow(exitPoint, weightedEntryPoint) ||\n    exitDir === 'down' && isBelow(weightedEntryPoint, exitPoint)\n  ) return true;\n\n  return false;\n};\n\n/**\n * Sort the candidates ordered by distance to the elem,\n * and filter out invalid candidates.\n * Prioritizes candidates that are aligned on the movement axis.\n *\n * @param {HTMLElement[]} candidates A set of candidate elements to sort\n * @param {HTMLElement} elem The search origin\n * @param {string} exitDir The direction in which we exited the elem (left, right, up, down)\n * @return {HTMLElement[]} The valid candidates, in order by distance\n */\nconst sortValidCandidates = (candidates, elem, exitDir) => {\n  const exitRect = elem?.getBoundingClientRect() || { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0 }; // For default case\n  const exitPoint = getMidpointForEdge(exitRect, exitDir);\n  const EPSILON = 1e-6;\n  const AXIS_OVERLAP_THRESHOLD = 0.3;\n\n  const getAxisOverlapRatio = (originRect, entryRect) => {\n    if (!originRect || !entryRect) return 0;\n    if (exitDir === 'left' || exitDir === 'right') {\n      const overlap = Math.max(0, Math.min(originRect.bottom, entryRect.bottom) - Math.max(originRect.top, entryRect.top));\n      return originRect.height > 0 ? overlap / originRect.height : 0;\n    }\n\n    const overlap = Math.max(0, Math.min(originRect.right, entryRect.right) - Math.max(originRect.left, entryRect.left));\n    return originRect.width > 0 ? overlap / originRect.width : 0;\n  };\n\n  return candidates.filter(candidate => {\n    // Filter out candidates that are in the opposite direction or have no dimensions\n    const entryRect = candidate.getBoundingClientRect();\n    const allowedOverlap = parseFloat(candidate.getAttribute('data-lrud-overlap-threshold'));\n    return isValidCandidate(entryRect, exitDir, exitPoint, allowedOverlap);\n  }).map((candidate, idx) => {\n    const entryRect = candidate.getBoundingClientRect();\n    const nearestPoint = getNearestPoint(exitPoint, exitDir, entryRect);\n    const distance = getDistanceBetweenPoints(exitPoint, nearestPoint);\n    const axisOverlapRatio = getAxisOverlapRatio(exitRect, entryRect);\n    const axisOverlap = axisOverlapRatio >= AXIS_OVERLAP_THRESHOLD;\n\n    // Calculate alignment score: 0 = perfectly aligned, higher = less aligned\n    const alignmentDelta = (exitDir === 'left' || exitDir === 'right')\n      ? Math.abs(exitPoint.y - nearestPoint.y) // Vertical alignment for horizontal movement\n      : Math.abs(exitPoint.x - nearestPoint.x); // Horizontal alignment for vertical movement\n\n    return {\n      candidate,\n      distance,\n      alignmentDelta,\n      axisOverlap,\n      idx\n    };\n  }).sort((a, b) => {\n    // Primary: Prefer candidates overlapping the origin axis band\n    if (a.axisOverlap !== b.axisOverlap) return a.axisOverlap ? -1 : 1;\n\n    if (a.axisOverlap && b.axisOverlap) {\n      // When within the axis band, prioritize distance over alignment\n      const distanceDiff = a.distance - b.distance;\n      if (Math.abs(distanceDiff) > EPSILON) return distanceDiff;\n\n      const alignmentDiff = a.alignmentDelta - b.alignmentDelta;\n      if (Math.abs(alignmentDiff) > EPSILON) return alignmentDiff;\n    } else {\n      // Otherwise, preserve alignment-first behavior\n      const alignmentDiff = a.alignmentDelta - b.alignmentDelta;\n      if (Math.abs(alignmentDiff) > EPSILON) return alignmentDiff;\n\n      const distanceDiff = a.distance - b.distance;\n      if (Math.abs(distanceDiff) > EPSILON) return distanceDiff;\n    }\n\n    // Tertiary: Preserve DOM order\n    return a.idx - b.idx;\n  }).map(({ candidate }) => candidate);\n};\n\n/**\n * Get a possible destination (if set) for a container\n * @param {HTMLElement} parentContainer The parent container\n * @return {HTMLElement | null | -1} The element that should get the focus next, (null if nothing to focus, undefined if no destinations available)\n */\nconst getPreferredDestination = (parentContainer) => {\n  // Use destinations if available to find new focus\n  const destinations = parentContainer?.getAttribute(DESTINATIONS_ATTRIBUTE);\n  if (destinations?.length) {\n    // Find the first valid element and set that as newFocus\n    const candidateIDs = destinations.split(' ');\n    let newFocus = null;\n    for (let candidateID of candidateIDs) {\n      newFocus = document.getElementById(candidateID);\n      if (newFocus) {\n        break;\n      }\n    }\n    return newFocus;\n  } else {\n    return undefined;\n  }\n};\n\n/**\n * Run autofocus logic to find next focus\n *\n * @param {HTMLElement} elem The starting element\n * @param {string} exitDir The direction exited from the starting element\n * @param {HTMLElement} candidateContainer Container on which autofocus logic needs run\n * @param {boolean} domOrderAsDefault How to get default focus if no destinations or data-focus found\n * (true: first focusable in DOM order, false: first focusable as per LRUD logic)\n * @return {{elem: HTMLElement|null, parentHasAutofocus: boolean}  } Next focus element in container\n */\nconst findDestinationOrAutofocus = (elem, exitDir, candidateContainer, domOrderAsDefault) => {\n  const hasAutoFocus = candidateContainer?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n  let newFocus = { elem: null, parentHasAutofocus: hasAutoFocus };\n\n  // 1. Use destinations (if available) to find new focus\n  newFocus.elem = getPreferredDestination(candidateContainer);\n  if (newFocus.elem !== undefined && newFocus.elem !== null) {\n      return newFocus;\n  }\n  // Provide details that no valid destination could be found\n  if (newFocus.elem === null) {\n    _noValidDestinationCallback(candidateContainer, hasAutoFocus);\n  }\n\n  if (newFocus.elem === null && !hasAutoFocus) {\n    // We are here because the element does not exist anymore\n    // Strangely, on RNTVOS for Android TV\n    // it keeps focussing on the first element of the container\n    // This may be a bug...\n    // So, we fallback to default focus logic (unless autofocus is set)\n    const candidateContainerFocusables = getFocusables(null, candidateContainer);\n    const candidates = sortValidCandidates(candidateContainerFocusables, elem, exitDir);\n    newFocus = getNextFromCandidates(candidates, elem, exitDir);\n    return newFocus;\n  }\n\n  if (hasAutoFocus) {\n    newFocus.elem = document.getElementById(candidateContainer?.getAttribute(DATA_FOCUS_ATTRIBUTE));\n    if (newFocus.elem) {\n      return newFocus;\n    }\n    // Get default inside the container\n    if (domOrderAsDefault) {\n      // First focusable in DOM order\n      newFocus = getFirstFocusableElement(candidateContainer);\n    } else {\n      // Based on experiments on Android TV\n      // the first focusable child as per LRUD logic\n      const candidateContainerFocusables = getFocusables(null, candidateContainer);\n      const candidates = sortValidCandidates(candidateContainerFocusables, elem, exitDir);\n      newFocus = getNextFromCandidates(candidates, elem, exitDir);\n    }\n    // Container may be empty or another Container. No further processing into child containers required\n    return newFocus;\n  }\n\n  return { elem: null, parentHasAutofocus: hasAutoFocus };\n};\n\n/**\n * Get one from the possible focusable candidates\n *\n * @param {HTMLElement[]} focusableCandidates Possible candidates list to choose from\n * @param {HTMLElement} elem The search origin (currently focused element)\n * @param {string} exitDir Direction requested\n * @return {{elem: HTMLElement|null, parentHasAutofocus: boolean}} candidate that gets the next focus or null if nothing valid found\n */\n\nconst getNextFromCandidates = (focusableCandidates, elem, exitDir) => {\n  /**\n   * The Candidates are already sorted by distance and filtered for valid direction\n   * Now we need to check each candidate for:\n   *  - if blockExits are available for current origins container and exitDir matches that\n   *  - if block exit is false\n   *    - if candidate is a container\n   *      - run autofocus logic on container to find next focus\n   *    - if candidate is not a container\n   *     - return candidate as is\n   */\n  let nextFocus = { elem: null, parentHasAutofocus: false };\n  const originsBlockedInfo = getParentContainerWithBlockedExits(elem);\n  const exitsBlocked = originsBlockedInfo?.blockExits?.includes(exitDir);\n\n  for (const candidate of focusableCandidates) {\n    // iscontainer will true for only focusable containers,\n    // as non focusable containers are filtered out in getFocusables function\n    const candidateIsContainer = isContainer(candidate);\n    if (exitsBlocked) {\n      // If candidate is not a child of originsBlockedInfo.parent,\n      // it means we are trying to exit the container with block exit, return null\n      if (!isStrictDescendant(candidate, originsBlockedInfo.parent)) {\n        return { elem: null, parentHasAutofocus: false };\n      }\n    }\n\n    if (candidateIsContainer) {\n      // Found a tvFocusable container, run the autofocus logic\n      nextFocus = findDestinationOrAutofocus(elem, exitDir, candidate, true);\n      return nextFocus;\n    } else {\n      // If the candidate is not a container, we can return it as is\n      const parentHasAutofocus = getFocusableParentContainer(candidate)?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n      nextFocus = { elem: candidate, parentHasAutofocus };\n      return nextFocus;\n    }\n  }\n  // If here, nothing could be found\n  return nextFocus;\n};\n\n/**\n * Update auto focus information for all ancestors (.lrud-container which have auto-focus=true)\n * by setting their data-focus attribute to provided child's id\n *\n * @param {HTMLElement} elem The element representing the search origin (currently focused element)\n * @param {HTMLElement} scope The element LRUD spatial is scoped to operate within\n */\nexport const updateAncestorsAutoFocus = (elem, scope) => {\n  // Traverse up the DOM tree and update all ancestor .lrud-container with data-autofocus=\"true\"\n  let current = elem.parentElement;\n  while (current && current !== scope && current.tagName !== 'BODY') {\n    if (isContainerWithAutofocus(current)) {\n      current.setAttribute(DATA_FOCUS_ATTRIBUTE, elem.id);\n    }\n    current = current.parentElement;\n  }\n};\n\n/**\n * Get the next focus candidate\n *\n * @param {HTMLElement} elem The search origin (currently focused element)\n * @param {string|number} keyOrKeyCode The key or keyCode value (from KeyboardEvent) of the pressed key\n * @param {HTMLElement} scope The element LRUD spatial is scoped to operate within\n * @return {{elem: HTMLElement, parentHasAutofocus: boolean}} The element that should receive focus next\n */\nexport const getNextFocus = (elem, keyOrKeyCode, scope) => {\n  /**\n   * If no scope provided, use document body\n   * If no elem provided, find a default focus inside scope\n   *\n   * Get all candidates inside scope (focusable and with container collapse/expand logic)\n   * Sort and filter candidates based on direction and distance\n   * Find next focus from candidates\n   * If still not found, return null\n   */\n  const exitDir = _keyMap[keyOrKeyCode];\n  if (!scope || !scope.querySelector) scope = document.body;\n  if (!elem) return getDefaultFocus(scope, exitDir);\n\n  let nextFocus = null;\n\n  let candidates = [];\n  const focusables = getAllFocusables(elem, scope);\n  candidates = sortValidCandidates(focusables, elem, exitDir);\n  nextFocus = getNextFromCandidates(candidates, elem, exitDir);\n  return nextFocus;\n};"],"mappings":"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","ignoreList":[]}