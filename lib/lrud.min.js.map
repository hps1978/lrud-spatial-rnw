{"version":3,"file":"lrud.min.js","names":["focusableSelector","LRUD_CONTAINER","ignoreSelector","DESTINATIONS_ATTRIBUTE","DATA_BLOCK_EXIT_ATTRIBUTE","DATA_AUTOFOCUS_ATTRIBUTE","DATA_FOCUS_ATTRIBUTE","_left","_right","_up","_down","_keyMap","setConfig","exports","config","keyMap","isContainer","node","_node$classList","classList","contains","isContainerWithAutofocus","_node$classList2","getAttribute","isContainerTVFocusable","_node$classList3","_node$getAttribute","length","toArray","nodeList","Array","prototype","slice","call","getParentContainer","elem","parentElement","tagName","getFirstFocusable","container","focusables","querySelectorAll","getFocusables","scope","_focusables2","ignoredElements","filter","some","ignored","parseInt","_focusables","childrenToIgnore","Set","forEach","allChildren","child","add","size","_focusables3","has","getDefaultFocus","exitDir","nextFocus","parentHasAutofocus","candidates","getAllFocusables","candidate","candidateIsContainer","findDestinationOrAutofocus","concat","getMidpointForEdge","rect","dir","x","left","y","top","bottom","right","getNearestPoint","point","getDistanceBetweenPoints","a","b","Math","sqrt","pow","isBelow","isRight","isValidCandidate","entryRect","exitPoint","entryWeighting","width","height","weightedEntryPoint","sortValidCandidates","exitRect","getBoundingClientRect","EPSILON","allowedOverlap","parseFloat","map","idx","nearestPoint","distance","alignmentDelta","abs","sort","alignmentDiff","distanceDiff","_ref","getPreferredDestination","parentContainer","destinations","candidateIDs","split","newFocus","_iterator","_createForOfIteratorHelper","_step","s","n","done","candidateID","value","document","getElementById","err","e","f","undefined","candidateContainer","domOrderAsDefault","hasAutoFocus","destination","_sortValidCandidates","candidateContainerFocusables","getNextFromCandidates","focusableCandidates","originContainer","blockExits","allowBlockExits","includes","_iterator2","_step2","candidatesContainer","_getParentContainer2","updateAncestorsAutoFocus","current","setAttribute","id","getNextFocus","keyOrKeyCode","querySelector","body"],"sources":["lrud.js"],"sourcesContent":["/**\n * LRUD: Spatial Edition\n *\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *  @@@@@@      '@@@@@@@@@   @@@@@@      '@@@@@@@@@   @@@@@@@@      '@@@@@@@\n *  @@@@@@  @@.   @@@@@@@@   @@@@@@  @@.    @@@@@@@   @@@@@     @@@@.   @@@@\n *  @@@@@@  @@@@  @@@@@@@@   @@@@@@  @@@@   @@@@@@@   @@@@   @@@@@@@@@@@@@@@\n *  @@@@@@        @@@@@@@@   @@@@@@        @@@@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@.  @@@@@@   @@@@@@  @@@@@.  @@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@   @@@@@@   @@@@@@  @@@@@   @@@@@@   @@@@    @@@@@@@@/ @@@@\n *  @@@@@@        /@@@@@@@   @@@@@@        /@@@@@@@   @@@@@@\\,         @@@@@\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *\n * Copyright (C) 2023 BBC.\n */\n\n// Any \"interactive content\" https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Interactive_content\nconst focusableSelector = '[tabindex], a, input, button';\nconst LRUD_CONTAINER = 'lrud-container';\nconst ignoreSelector = '.lrud-ignore, [disabled]';\nconst DESTINATIONS_ATTRIBUTE = 'data-destinations';\nconst DATA_BLOCK_EXIT_ATTRIBUTE = 'data-block-exit';\nconst DATA_AUTOFOCUS_ATTRIBUTE = 'data-autofocus';\nconst DATA_FOCUS_ATTRIBUTE = 'data-focus';\n// const PRIORITISE_CHILDREN_ATTRIBUTE = 'data-lrud-prioritise-children'; // Only set when data-block-exit are set\n\n/**\n * This is how the React Native Web TV props are mapped here:\n *\n * 1. TVFocusGuideView.tvFocusable={true} OR container={true} -> .lrud-container (tabindex=-1)\n *    (at the moment when TVFocusGuideView is used, looks like the directional navigation prioritises it's children irrespective of\n *    the value of tvFocusable prop. So we are mapping container={true} to .lrud-container as well)\n *    Rest of the attributes and logic for TVFocusGuideView is only valid if .lrud-container is present.\n * 2. TVFocusGuideView.focusable={false} -> sets .lrud-ignore : Ignores .lrud-container and it's children for LRUD logic\n * 3. TVFocusGuideView.autoFocus={true} -> data-autofocus attribute is 'true'/'false'. The attribute controls whether\n *    data-focus in parent containers should be applied or not. And stores last focused child in data-focus attribute.\n * 4. TVFocusGuideView.destinations=[\"id1\", \"id2\"] -> data-destinations=\"id1 id2\": These ids are from\n *    id assigned to each of the destination elements. This overrides data-focus logic (whether present or not).\n * 5. TVFocusGuideView.trapFocusUp={true} -> data-block-exit=\"up\"\n * 6. TVFocusGuideView.trapFocusDown={true} -> data-block-exit=\"down\"\n * 7. TVFocusGuideView.trapFocusLeft={true} -> data-block-exit=\"left\"\n * 8. TVFocusGuideView.trapFocusRight={true} -> data-block-exit=\"right\"\n *\n * Rules:\n * - For the first time focus:\n *  1. Default rule is to focus the first focusable element in the DOM tree order.\n *  2. If that element is in a .lrud-container and that container has data-autofocus=\"true\", then:\n *   a. If that container has data-destinations, first valid element from that list is focused.\n *   b. Else if that container has data-focus set to a valid element id, that element is focused.\n *   c. Else first focusable element as per LRUD logic is focused: On Android TV this seems to be the one closest to top-left corner of the container/window.\n *\n * - Candidates selection on directional navigation:\n *  1. The selection is influenced by the direction of the navigation (up, down, left, right).\n *  2. Candidates are selected based on their proximity to the currently focused element.\n *  3. All elements with tabindex>=0 are considered as candidates by default (with some exceptions as described below).\n *  4. The candidate search is container within the scope first (if provided).\n *  3. All elements with tabindex=\"-1\" are ignored unless they are .lrud-container elements (which requires special logic as described below).\n *  4. All elements with .lrud-ignore class or disabled attribute are ignored along with their children.\n *  5. If an element is a .lrud-container with data-autofocus=\"true\"\n *     - AND the current focus is NOT inside that container\n *       - the container itself becomes a candidate and it's children are ignored.\n *  6. If an element is a .lrud-container with data-autofocus=\"true\"\n *     - AND the current focus is outside that container\n *       - the container's children as considered as candidates and container itself is ignored.\n *\n * - Focus selection from candidates:\n * 1. From the list of candidates, the one that is closest to the current focus in the requested direction is selected.\n * 2. If the selected candidate is a .lrud-container with data-autofocus=\"true\", the following logic is applied to determine the actual focus:\n *   a. If the container has data-destinations, the first valid element from that list is focused.\n *   b. Else if the container has data-focus set to a valid element id, that element is focused.\n *   c. Else the first focusable element inside the container is focused.\n * 3. If the selected candidate is not a .lrud-container, and does not have data-autofocus=\"true\", the container is returned.\n * 4. If no valid candidate is found, null is returned.\n *\n * This module does not have a state of it's own. It relies on the DOM structure and attributes\n * to determine the next focusable element. It does not manage focus itself. If it successfully finds a new focus element,\n * it returns that element and details if that element is a container with data-autofocus=\"true\".\n * The calling code is responsible for actually setting the focus to that element.\n */\n\nconst _left = 'left', _right = 'right', _up = 'up', _down = 'down';\nlet _keyMap = {\n  4: _left,\n  21: _left,\n  37: _left,\n  214: _left,\n  205: _left,\n  218: _left,\n  5: _right,\n  22: _right,\n  39: _right,\n  213: _right,\n  206: _right,\n  217: _right,\n  29460: _up,\n  19: _up,\n  38: _up,\n  211: _up,\n  203: _up,\n  215: _up,\n  29461: _down,\n  20: _down,\n  40: _down,\n  212: _down,\n  204: _down,\n  216: _down,\n  'ArrowLeft': _left,\n  'ArrowRight': _right,\n  'ArrowUp': _up,\n  'ArrowDown': _down\n};\n\nexport const setConfig = (config) => {\n  _keyMap = config.keyMap || _keyMap;\n};\n\n// const hasDOM = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof Element !== 'undefined';\n\n// // Element.matches() with fallbacks for older browsers\n// const matchesFunction = hasDOM && (window.Element.prototype.matches ||\n//   window.Element.prototype.matchesSelector ||\n//   window.Element.prototype.mozMatchesSelector ||\n//   window.Element.prototype.msMatchesSelector ||\n//   window.Element.prototype.oMatchesSelector) ||\n//   function(s) {\n//     var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n//       i = matches.length;\n//     // eslint-disable-next-line no-empty\n//     while (--i >= 0 && matches.item(i) !== this) {}\n//     return i > -1;\n//   };\n\n// /**\n//  * Element API .matches() with fallbacks\n//  */\n// const matches = (element, selectors) => {\n//   if (!element) {\n//     console.warn('matches() passed with a null element');\n//     return false;\n//   }\n\n//   return matchesFunction.call(element, selectors);\n// };\n\nconst isContainer = (node) => node?.classList?.contains(LRUD_CONTAINER);\n\nconst isContainerWithAutofocus = (node) =>\n  node?.classList?.contains(LRUD_CONTAINER) &&\n  node?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n\n// const isContainerWithDestinations = (node) =>\n//   node?.classList?.contains(LRUD_CONTAINER) &&\n//   node?.getAttribute(DESTINATIONS_ATTRIBUTE)?.length > 0;\n\nconst isContainerTVFocusable = (node) =>\n  // A tvFocusable is a container with either data-autofocus or data-destinations set\n  node?.classList?.contains(LRUD_CONTAINER) &&\n  (node?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true' ||\n    node?.getAttribute(DESTINATIONS_ATTRIBUTE)?.length > 0);\n\n/**\n * Convert a NodeList to a regular Array\n *\n * @param {NodeList} nodeList The NodeList representation\n * @return {Array|null} The Array representation\n */\nconst toArray = (nodeList) => Array.prototype.slice.call(nodeList);\n\n/**\n * Traverse DOM ancestors until we find a focus container\n *\n * @param {HTMLElement} elem The element representing the search origin\n * @return {HTMLElement|null} The parent focus container or null\n */\nexport const getParentContainer = (elem) => {\n  if (!elem.parentElement || elem.parentElement.tagName === 'BODY') {\n    return null;\n  } else if (isContainer(elem.parentElement)) {\n    return elem.parentElement;\n  }\n\n  return getParentContainer(elem.parentElement);\n};\n\n/**\n * Get first focusable (non container) inside a container,\n * or null if none exists\n *\n * @param {HTMLElement} container The container element to search inside\n * @return {HTMLElement|null} The first focusable element or null\n */\nconst getFirstFocusable = (container) => {\n  if (!container) return null;\n\n  const focusables = toArray(container.querySelectorAll(focusableSelector));\n\n  return focusables.length > 0 ? focusables[0] : null;\n};\n\n/**\n * Get all focusable elements inside `scope`,\n * discounting any that are ignored or inside an ignored container\n *\n * @param {HTMLElement|null} elem The element representing the search origin (currently focused element)\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getFocusables = (elem, scope) => {\n  if (!scope) return [];\n  /**\n   * Get all elements (within scope) that:\n   *  have a tabindex -> remove .lrud-ignore and children ->\n   *  filter all with tabindex=-1 unless .lrud-container (with data-autofocus=\"true\") ->\n   *  filter all .lrud-container with focus inside (could be nested containers) ->\n   *  filter all children of .lrud-container with data-autofocus=\"true\" OR data-destinations=[...]\n   */\n\n  const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n  let focusables = toArray(scope.querySelectorAll(focusableSelector))\n    .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n    .filter(node => isContainerTVFocusable(node) || parseInt(node.getAttribute('tabindex') || '-1', 10) > -1);\n\n  if (elem) {\n    // To remove containers that have focus inside them\n    focusables = focusables?.filter(node => (isContainer(node) && node.contains(elem)) ? false : true);\n  }\n\n  // Create a set of children to ignore from containers with data-autofocus=\"true\" or data-destinations\n  let childrenToIgnore = new Set();\n  focusables?.forEach(node => {\n    if (isContainerTVFocusable(node)) {\n      // add all focusable children to ignore set\n      const allChildren = toArray(node.querySelectorAll(focusableSelector));\n      allChildren.forEach(child => childrenToIgnore.add(child));\n    }\n  });\n\n  // Finally filter out all children that are in the ignore set\n  if (childrenToIgnore.size > 0) {\n    focusables = focusables?.filter(node => !childrenToIgnore.has(node));\n  }\n  return focusables;\n};\n\n/**\n * Get first focusable element as a default focus inside a 'scope'\n *\n * @param {HTMLElement} scope The element to search inside of\n * @param {String} exitDir The direction we exited from the starting element\n * @return {{elem: HTMLElement|null, parentHasAutofocus: boolean}} First focusable HTML Element\n */\nconst getDefaultFocus = (scope, exitDir) => {\n  let nextFocus = {elem: null, parentHasAutofocus: false};\n  const candidates = getAllFocusables(null, scope);\n  if (candidates.length > 0) {\n    let candidate = candidates[0];\n    // First candiate may be a container with autofocus or destinations\n    const candidateIsContainer = isContainer(candidate);\n    if (candidateIsContainer) {\n       nextFocus = findDestinationOrAutofocus(null, exitDir, candidate, false);\n    } else {\n      nextFocus = { elem: candidate, parentHasAutofocus: false };\n    }\n  }\n  return nextFocus;\n};\n\n/**\n * Get all the focusable candidates inside `scope`,\n * including focusable containers\n *\n * @param {HTMLElement|null} elem The element representing the search origin (currently focused element)\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getAllFocusables = (elem, scope) =>\n  // const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n    [\n    // ...toArray(scope.querySelectorAll(focusableContainerSelector))\n      // .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n      // .filter(container => getFocusables(container)?.length > 0),\n    ...getFocusables(elem, scope)\n  ];\n\n// /**\n//  * Build an array of ancestor containers\n//  *\n//  * @param {HTMLElement} initialContainer The container to start from\n//  * @return {HTMLElement[]} An array of ancestor containers\n//  */\n// const collectContainers = (initialContainer) => {\n//   if (!initialContainer) return [];\n//   const acc = [ initialContainer ];\n//   let cur = initialContainer;\n//   while (cur) {\n//     cur = getParentContainer(cur);\n//     if (cur) acc.push(cur);\n//   }\n//   return acc;\n// };\n\n/**\n * Get the middle point of a given edge\n *\n * @param {Object} rect An object representing the rectangle\n * @param {String} dir The direction of the edge (left, right, up, down)\n * @return {Point} An object with the X and Y coordinates of the point\n */\nconst getMidpointForEdge = (rect, dir) => {\n  switch (dir) {\n    case 'left':\n      return { x: rect.left, y: (rect.top + rect.bottom) / 2 };\n    case 'right':\n      return { x: rect.right, y: (rect.top + rect.bottom) / 2 };\n    case 'up':\n      return { x: (rect.left + rect.right) / 2, y: rect.top };\n    case 'down':\n      return { x: (rect.left + rect.right) / 2, y: rect.bottom };\n  }\n};\n\n/**\n * Gets the nearest point on `rect` that a line in direction `dir` from `point` would hit\n * If the rect is exactly in direction `dir` then the point will be in a straight line from `point`.\n * Otherwise it will be the nearest corner of the target rect.\n *\n * @param {Point} point The point to start from\n * @param {String} dir The direction to draw the line in\n * @param {Object} rect An object representing the rectangle of the item we're going to\n * @return {Point} An object with the X/Y coordinates of the nearest point\n */\nconst getNearestPoint = (point, dir, rect) => {\n  if (dir === 'left' || dir === 'right') {\n    // When moving horizontally...\n    // The nearest X is always the nearest edge, left or right\n    const x = dir === 'left' ? rect.right : rect.left;\n\n    // If the start point is higher than the rect, nearest Y is the top corner\n    if (point.y < rect.top) return { x, y: rect.top };\n    // If the start point is lower than the rect, nearest Y is the bottom corner\n    if (point.y > rect.bottom) return { x, y: rect.bottom };\n    // Else the nearest Y is aligned with where we started\n    return { x, y: point.y };\n  } else if (dir === 'up' || dir === 'down') {\n    // When moving vertically...\n    // The nearest Y is always the nearest edge, top or bottom\n    const y = dir === 'up' ? rect.bottom : rect.top;\n\n    // If the start point is left-er than the rect, nearest X is the left corner\n    if (point.x < rect.left) return { x: rect.left, y };\n    // If the start point is right-er than the rect, nearest X is the right corner\n    if (point.x > rect.right) return { x: rect.right, y };\n    // Else the nearest X is aligned with where we started\n    return { x: point.x, y };\n  }\n};\n\n/**\n * Get the Pythagorean distance between two points\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {number} Distance from A to B\n */\nconst getDistanceBetweenPoints = (a, b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n\n/**\n * Check if point A is below point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is below b, false otherwise\n */\nconst isBelow = (a, b) => a.y > b.y;\n\n/**\n * Check if point A is to the right of point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is to the right of b, false otherwise\n */\nconst isRight = (a, b) => a.x > b.x;\n\n// /**\n//  * Get blocked exit directions for current node\n//  *\n//  * @param {HTMLElement} originContainer Current focus container\n//  * @param {HTMLElement} candidateContainer Candidate focus container\n//  * @return {string[]} Array of strings representing blocked directions\n//  */\n// const getBlockedExitDirs = (originContainer, candidateContainer) => {\n//   if (!originContainer) {\n//     return [];\n//   }\n\n//   const currentAncestorContainers = collectContainers(originContainer);\n//   const candidateAncestorContainers = collectContainers(candidateContainer);\n\n//   // Find common container for current container and candidate container and\n//   // remove everything above it\n//   for (let i = 0; i < candidateAncestorContainers.length; i++) {\n//     let commonCandidate = candidateAncestorContainers[i];\n\n//     const spliceIndex = currentAncestorContainers.indexOf(commonCandidate);\n\n//     if (spliceIndex > -1) {\n//       currentAncestorContainers.splice(spliceIndex);\n//       break;\n//     }\n//   }\n\n//   return currentAncestorContainers.reduce((acc, cur) => {\n//     const dirs = (cur?.getAttribute(DATA_BLOCK_EXIT_ATTRIBUTE) || '').split(' ');\n\n//     return acc.concat(dirs);\n//   }, []);\n// };\n\n/**\n * Check if the candidate is in the `exitDir` direction from the rect we're leaving,\n * with an overlap allowance of entryWeighting as a percentage of the candidate's width.\n *\n * @param {Object} entryRect An object representing the rectangle of the item we're moving to\n * @param {String} exitDir The direction we're moving in\n * @param {Object} exitPoint The midpoint of the edge we're leaving\n * @param {Float} entryWeighting Percentage of the candidate that is allowed to be behind the target\n * @return {Booelan} true if candidate is in the correct dir, false if not\n */\nconst isValidCandidate = (entryRect, exitDir, exitPoint, entryWeighting) => {\n  if (entryRect.width === 0 && entryRect.height === 0) return false;\n  if (!entryWeighting && entryWeighting != 0) entryWeighting = 0.3;\n\n  const weightedEntryPoint = {\n    x: entryRect.left + (entryRect.width * (exitDir === 'left' ? 1 - entryWeighting : exitDir === 'right' ? entryWeighting : 0.5)),\n    y: entryRect.top + (entryRect.height * (exitDir === 'up' ? 1 - entryWeighting : exitDir === 'down' ? entryWeighting : 0.5))\n  };\n\n  if (\n    exitDir === 'left' && isRight(exitPoint, weightedEntryPoint) ||\n    exitDir === 'right' && isRight(weightedEntryPoint, exitPoint) ||\n    exitDir === 'up' && isBelow(exitPoint, weightedEntryPoint) ||\n    exitDir === 'down' && isBelow(weightedEntryPoint, exitPoint)\n  ) return true;\n\n  return false;\n};\n\n/**\n * Sort the candidates ordered by distance to the elem,\n * and filter out invalid candidates.\n * Prioritizes candidates that are aligned on the movement axis.\n *\n * @param {HTMLElement[]} candidates A set of candidate elements to sort\n * @param {HTMLElement} elem The search origin\n * @param {string} exitDir The direction in which we exited the elem (left, right, up, down)\n * @return {HTMLElement[]} The valid candidates, in order by distance\n */\nconst sortValidCandidates = (candidates, elem, exitDir) => {\n  const exitRect = elem?.getBoundingClientRect() || { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0 }; // For default case\n  const exitPoint = getMidpointForEdge(exitRect, exitDir);\n  const EPSILON = 1e-6;\n\n  return candidates.filter(candidate => {\n    // Filter out candidates that are in the opposite direction or have no dimensions\n    const entryRect = candidate.getBoundingClientRect();\n    const allowedOverlap = parseFloat(candidate.getAttribute('data-lrud-overlap-threshold'));\n    return isValidCandidate(entryRect, exitDir, exitPoint, allowedOverlap);\n  }).map((candidate, idx) => {\n    const entryRect = candidate.getBoundingClientRect();\n    const nearestPoint = getNearestPoint(exitPoint, exitDir, entryRect);\n    const distance = getDistanceBetweenPoints(exitPoint, nearestPoint);\n\n    // Calculate alignment score: 0 = perfectly aligned, higher = less aligned\n    const alignmentDelta = (exitDir === 'left' || exitDir === 'right')\n      ? Math.abs(exitPoint.y - nearestPoint.y) // Vertical alignment for horizontal movement\n      : Math.abs(exitPoint.x - nearestPoint.x); // Horizontal alignment for vertical movement\n\n    return {\n      candidate,\n      distance,\n      alignmentDelta,\n      idx\n    };\n  }).sort((a, b) => {\n    // Primary: Sort by alignment (perfectly aligned candidates first)\n    const alignmentDiff = a.alignmentDelta - b.alignmentDelta;\n    if (Math.abs(alignmentDiff) > EPSILON) return alignmentDiff;\n\n    // Secondary: Sort by distance (closest candidates first)\n    const distanceDiff = a.distance - b.distance;\n    if (Math.abs(distanceDiff) > EPSILON) return distanceDiff;\n\n    // Tertiary: Preserve DOM order\n    return a.idx - b.idx;\n  }).map(({ candidate }) => candidate);\n};\n\n/**\n * Get the first parent container that matches the focusable candidate selector\n * @param {HTMLElement} startingCandidate The starting candidate to get the parent container of\n * @return {HTMLElement} The container that matches or null\n */\n// const getParentFocusableContainer = (startingCandidate) => {\n//   if (!startingCandidate) return null;\n//   do {\n//     startingCandidate = getParentContainer(startingCandidate);\n//   } while (startingCandidate && !matches(startingCandidate, focusableContainerSelector));\n\n//   return startingCandidate;\n// };\n\n/**\n * Get a possible destination (if set) for a container\n * @param {HTMLElement} parentContainer The parent container\n * @return {HTMLElement | null | -1} The element that should get the focus next, (null if nothing to focus, undefined if no destinations available)\n */\nconst getPreferredDestination = (parentContainer) => {\n  // Use destinations if available to find new focus\n  const destinations = parentContainer?.getAttribute(DESTINATIONS_ATTRIBUTE);\n  if (destinations?.length) {\n    // Find the first valid element and set that as newFocus\n    const candidateIDs = destinations.split(' ');\n    let newFocus = null;\n    for (let candidateID of candidateIDs) {\n      newFocus = document.getElementById(candidateID);\n      if (newFocus) {\n        break;\n      }\n    }\n    return newFocus;\n  } else {\n    return undefined;\n  }\n};\n\n/**\n * Run autofocus logic to find next focus\n *\n * @param {HTMLElement} elem The starting element\n * @param {string} exitDir The direction exited from the starting element\n * @param {HTMLElement} candidateContainer Container on which autofocus logic needs run\n * @param {boolean} domOrderAsDefault How to get default focus if no destinations or data-focus found\n * (true: first focusable in DOM order, false: first focusable as per LRUD logic)\n * @return {{elem: HTMLElement|null, parentHasAutofocus: boolean}  } Next focus element in container\n */\nconst findDestinationOrAutofocus = (elem, exitDir, candidateContainer, domOrderAsDefault) => {\n  const hasAutoFocus = candidateContainer?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n  // 1. Use destinations (if available) to find new focus\n  const destination = getPreferredDestination(candidateContainer);\n  if (destination !== undefined && destination !== null) {\n      return { elem: destination, parentHasAutofocus: hasAutoFocus };\n  }\n  // Use last known active child or first focusable child\n  if (hasAutoFocus) {\n    let newFocus = document.getElementById(candidateContainer?.getAttribute(DATA_FOCUS_ATTRIBUTE));\n    if (newFocus) {\n      return { elem: newFocus, parentHasAutofocus: hasAutoFocus };\n    }\n    // Get first focusable child\n    if (domOrderAsDefault) {\n      // First focusable in DOM order\n      newFocus = getFirstFocusable(candidateContainer);\n    } else {\n      // Based on experiments on Android TV\n      // the first focusable child as per LRUD logic\n      const candidateContainerFocusables = getFocusables(null, candidateContainer);\n      newFocus = sortValidCandidates(candidateContainerFocusables, elem, exitDir)?.[0];\n    }\n    // Container may be empty or another Container. No further processing into child containers required\n    return { elem: newFocus, parentHasAutofocus: hasAutoFocus };\n  }\n\n  return { elem: null, parentHasAutofocus: hasAutoFocus };\n};\n\n/**\n * Get one from the possible focusable candidates\n *\n * @param {HTMLElement[]} focusableCandidates Possible candidates list to choose from\n * @param {HTMLElement} elem The search origin (currently focused element)\n * @param {string} exitDir Direction requested\n * @return {{elem: HTMLElement|null, parentHasAutofocus: boolean}} candidate that gets the next focus or null if nothing valid found\n */\n\nconst getNextFromCandidates = (focusableCandidates, elem, exitDir) => {\n  /**\n   * The Candidates are already sorted by distance and filtered for valid direction\n   * Now we need to check each candidate for:\n   *  - if blockExits are available for current container and match the exitDir\n   *    - if candidate is a not a container\n   *      - if parent container of candidate and current container are same -> return candidate\n   *      - else return null as exit is blocked\n   *    - if candidate is a container\n   *      - we've hit a block exit as we are trying to exit current container\n   *      - return null as exit is blocked\n   *  - if block exit is false\n   *    - if candidate is a container\n   *      - run autofocus logic on container to find next focus\n   *    - if candidate is not a container\n   *     - return candidate as is\n   */\n  let nextFocus = { elem: null, parentHasAutofocus: false };\n  const originContainer = getParentContainer(elem);\n  const blockExits = originContainer?.getAttribute(DATA_BLOCK_EXIT_ATTRIBUTE);\n  const allowBlockExits = !(blockExits && blockExits.length > 0 && blockExits.split(' ').includes(exitDir));\n\n  for (const candidate of focusableCandidates) {\n    const candidateIsContainer = isContainer(candidate);\n    if (!allowBlockExits) {\n      if (!candidateIsContainer) {\n        const candidatesContainer = getParentContainer(candidate);\n        if (candidatesContainer === originContainer) {\n          // Candidate is in the same container as current focus\n          const parentHasAutofocus = candidatesContainer?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n          return { elem: candidate, parentHasAutofocus };\n        }\n      }\n      // Trying to enter a different container, exit is blocked, return null\n      return { elem: null, parentHasAutofocus: false };\n    }\n\n    if (candidateIsContainer) {\n      // Found a tvFocusable container, run the autofocus logic\n      nextFocus = findDestinationOrAutofocus(elem, exitDir, candidate, true);\n      return nextFocus;\n    } else {\n      // If the candidate is not a container, we can return it as is\n      const parentHasAutofocus = getParentContainer(candidate)?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n      nextFocus = { elem: candidate, parentHasAutofocus };\n      return nextFocus;\n    }\n  }\n  // If here, nothing could be found\n  return nextFocus;\n};\n\n/**\n * Update auto focus information for all ancestors (.lrud-container which have auto-focus=true)\n * by setting their data-focus attribute to provided child's id\n *\n * @param {HTMLElement} elem The element representing the search origin (currently focused element)\n * @param {HTMLElement} scope The element LRUD spatial is scoped to operate within\n */\nexport const updateAncestorsAutoFocus = (elem, scope) => {\n  // Traverse up the DOM tree and update all ancestor .lrud-container with data-autofocus=\"true\"\n  let current = elem.parentElement;\n  while (current && current !== scope || current.tagName !== 'BODY') {\n    if (isContainerWithAutofocus(current)) {\n      current.setAttribute(DATA_FOCUS_ATTRIBUTE, elem.id);\n    }\n    current = current.parentElement;\n  }\n};\n\n/**\n * Get the next focus candidate\n *\n * @param {HTMLElement} elem The search origin (currently focused element)\n * @param {string|number} keyOrKeyCode The key or keyCode value (from KeyboardEvent) of the pressed key\n * @param {HTMLElement} scope The element LRUD spatial is scoped to operate within\n * @return {{elem: HTMLElement, parentHasAutofocus: boolean}} The element that should receive focus next\n */\nexport const getNextFocus = (elem, keyOrKeyCode, scope) => {\n  /**\n   * If no scope provided, use document body\n   * If no elem provided, find a default focus inside scope\n   *\n   * Get all candidates inside scope (focusable and with container collapse/expand logic)\n   * Sort and filter candidates based on direction and distance\n   * Find next focus from candidates\n   * If still not found, return null\n   */\n  const exitDir = _keyMap[keyOrKeyCode];\n  if (!scope || !scope.querySelector) scope = document.body;\n  if (!elem) return getDefaultFocus(scope, exitDir);\n\n  let nextFocus = null;\n\n  let candidates = [];\n  const focusables = getAllFocusables(elem, scope);\n  candidates = sortValidCandidates(focusables, elem, exitDir);\n  nextFocus = getNextFromCandidates(candidates, elem, exitDir);\n  return nextFocus;\n};"],"mappings":"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","ignoreList":[]}