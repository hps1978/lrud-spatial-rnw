{"version":3,"file":"lrud.min.js","names":["focusableSelector","containerSelector","ignoreSelector","DESTINATIONS_ATTRIBUTE","DATA_BLOCK_EXIT_ATTRIBUTE","AUTOFOCUS_ATTRIBUTE","DATA_FOCUS_ATTRIBUTE","PRIORITISE_CHILDREN_ATTRIBUTE","_left","_right","_up","_down","_keyMap","createMissingId","setConfig","exports","config","keyMap","getId","element","_element$id","id","length","matches","selectors","console","warn","fn","Element","prototype","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","s","document","ownerDocument","querySelectorAll","i","item","call","toArray","nodeList","Array","slice","getParentContainer","elem","parentElement","tagName","getFocusables","scope","ignoredElements","filter","node","some","ignored","contains","parseInt","getAttribute","getAllFocusables","concat","collectContainers","initialContainer","acc","cur","push","getMidpointForEdge","rect","dir","x","left","y","top","bottom","right","getNearestPoint","point","getDistanceBetweenPoints","a","b","Math","sqrt","pow","isBelow","isRight","getBlockedExitDirs","container","candidateContainer","currentAncestorContainers","candidateAncestorContainers","commonCandidate","spliceIndex","indexOf","splice","reduce","dirs","split","isValidCandidate","entryRect","exitDir","exitPoint","entryWeighting","width","height","weightedEntryPoint","sortValidCandidates","candidates","exitRect","getBoundingClientRect","candidate","allowedOverlap","parseFloat","map","nearestPoint","distance","sort","_ref","getPreferredDestination","parentContainer","destinations","candidateIDs","newFocus","_iterator","_createForOfIteratorHelper","_step","n","done","candidateID","value","getElementById","err","e","f","undefined","getNextFromCandidates","focusableCandidates","blockSetExits","_iterator2","_step2","candidateIsContainer","isCurrentContainer","isNestedContainer","isAnscestorContainer","blockedExitDirs","_getFocusables","candidateContainerAutoFocus","destination","setAttribute","lastActiveChild","getNextFocus","keyOrKeyCode","_getFocusables2","_parentContainer$getA","querySelector","body","nextFocus","valueOf","focusableSiblings"],"sources":["lrud.js"],"sourcesContent":["/**\n * LRUD: Spatial Edition\n *\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *  @@@@@@      '@@@@@@@@@   @@@@@@      '@@@@@@@@@   @@@@@@@@      '@@@@@@@\n *  @@@@@@  @@.   @@@@@@@@   @@@@@@  @@.    @@@@@@@   @@@@@     @@@@.   @@@@\n *  @@@@@@  @@@@  @@@@@@@@   @@@@@@  @@@@   @@@@@@@   @@@@   @@@@@@@@@@@@@@@\n *  @@@@@@        @@@@@@@@   @@@@@@        @@@@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@.  @@@@@@   @@@@@@  @@@@@.  @@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@   @@@@@@   @@@@@@  @@@@@   @@@@@@   @@@@    @@@@@@@@/ @@@@\n *  @@@@@@        /@@@@@@@   @@@@@@        /@@@@@@@   @@@@@@\\,         @@@@@\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *\n * Copyright (C) 2023 BBC.\n */\n\n// Any \"interactive content\" https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Interactive_content\nconst focusableSelector = '[tabindex], a, input, button';\nconst containerSelector = 'nav, section, .lrud-container'; // TODO: Do we need nav and section here anymore??\n// const focusableContainerSelector = '[data-lrud-consider-container-distance]'; // Manage using just the containerSelector\nconst ignoreSelector = '.lrud-ignore, [disabled]';\nconst DESTINATIONS_ATTRIBUTE = 'data-destinations';\nconst DATA_BLOCK_EXIT_ATTRIBUTE = 'data-block-exit';\nconst AUTOFOCUS_ATTRIBUTE = 'data-autofocus';\nconst DATA_FOCUS_ATTRIBUTE = 'data-focus';\nconst PRIORITISE_CHILDREN_ATTRIBUTE = 'data-lrud-prioritise-children'; // Only set when data-block-exit are set\n\n/**\n * This is how the React Native Web TV props are mapped here:\n *\n * 1. TVFocusGuideView.tvFocusable={true}  -> .lrud-container\n *    Rest of the attributes and logic for TVFocusGuideView is only valid if tvFocusable is true\n * 2. TVFocusGuideView.focusable={false} -> set .lrud-ignore : Ignores all elements under .lrud-container for focus logic\n * 3. TVFocusGuideView.autoFocus={true} -> TODO: data-autofocus attribute is 'true'/'false'. The attributes data-destinations and\n *    data-focus parent containers should only be applied when data-focus is true. Same for data-block-exit??\n * 4. TVFocusGuideView.trapFocusUp={true} -> data-block-exit=\"up\"\n * 5. TVFocusGuideView.trapFocusDown={true} -> data-block-exit=\"down\"\n * 6. TVFocusGuideView.trapFocusLeft={true} -> data-block-exit=\"left\"\n * 7. TVFocusGuideView.trapFocusRight={true} -> data-block-exit=\"right\"\n * 8. TVFocusGuideView.destinations=[\"id1\", \"id2\"] -> data-destinations=\"id1 id2\": These ids are from\n *    id assigned to each of the destination elements.\n *\n * Any other compoenents are navigated using the default lrud algorithm based on tabindex and role of elements.\n */\n\nconst _left = 'left', _right = 'right', _up = 'up', _down = 'down';\nlet _keyMap = {\n  4: _left,\n  21: _left,\n  37: _left,\n  214: _left,\n  205: _left,\n  218: _left,\n  5: _right,\n  22: _right,\n  39: _right,\n  213: _right,\n  206: _right,\n  217: _right,\n  29460: _up,\n  19: _up,\n  38: _up,\n  211: _up,\n  203: _up,\n  215: _up,\n  29461: _down,\n  20: _down,\n  40: _down,\n  212: _down,\n  204: _down,\n  216: _down,\n  'ArrowLeft': _left,\n  'ArrowRight': _right,\n  'ArrowUp': _up,\n  'ArrowDown': _down\n};\n\nlet createMissingId = null;\n\nexport const setConfig = (config) => {\n  _keyMap = config.keyMap || _keyMap;\n  createMissingId = typeof config.createMissingId === 'function' ? config.createMissingId : null;\n};\n\nconst getId = (element) => (element.id && element.id?.length) ? element.id : createMissingId ? createMissingId(element) : '';\n\n/**\n * Element API .matches() with fallbacks\n */\nconst matches = (element, selectors) => {\n  if (!element) {\n    console.warn('matches() passed with a null element');\n    return false;\n  }\n  const fn = Element.prototype.matches ||\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector ||\n    function(s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n        i = matches.length;\n      // eslint-disable-next-line no-empty\n      while (--i >= 0 && matches.item(i) !== this) {}\n      return i > -1;\n    };\n\n  return fn.call(element, selectors);\n};\n\n/**\n * Convert a NodeList to a regular Array\n *\n * @param {NodeList} nodeList The NodeList representation\n * @return {Array|null} The Array representation\n */\nconst toArray = (nodeList) => Array.prototype.slice.call(nodeList);\n\n/**\n * Traverse DOM ancestors until we find a focus container\n *\n * @param {HTMLElement} elem The element representing the search origin\n * @return {HTMLElement|null} The parent focus container or null\n */\nconst getParentContainer = (elem) => {\n  if (!elem.parentElement || elem.parentElement.tagName === 'BODY') {\n    return null;\n  } else if (matches(elem.parentElement, containerSelector)) {\n    return elem.parentElement;\n  }\n\n  return getParentContainer(elem.parentElement);\n};\n\n/**\n * Get all focusable elements inside `scope`,\n * discounting any that are ignored or inside an ignored container\n *\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getFocusables = (scope) => {\n  if (!scope) return [];\n\n  const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n  return toArray(scope.querySelectorAll(focusableSelector))\n    .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n    .filter(node => matches(node, containerSelector) || parseInt(node.getAttribute('tabindex') || '0', 10) > -1);\n};\n\n/**\n * Get all the focusable candidates inside `scope`,\n * including focusable containers\n *\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getAllFocusables = (scope) =>\n  // const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n    [\n    // ...toArray(scope.querySelectorAll(focusableContainerSelector))\n      // .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n      // .filter(container => getFocusables(container)?.length > 0),\n    ...getFocusables(scope)\n  ];\n\n/**\n * Build an array of ancestor containers\n *\n * @param {HTMLElement} initialContainer The container to start from\n * @return {HTMLElement[]} An array of ancestor containers\n */\nconst collectContainers = (initialContainer) => {\n  if (!initialContainer) return [];\n  const acc = [ initialContainer ];\n  let cur = initialContainer;\n  while (cur) {\n    cur = getParentContainer(cur);\n    if (cur) acc.push(cur);\n  }\n  return acc;\n};\n\n/**\n * Get the middle point of a given edge\n *\n * @param {Object} rect An object representing the rectangle\n * @param {String} dir The direction of the edge (left, right, up, down)\n * @return {Point} An object with the X and Y coordinates of the point\n */\nconst getMidpointForEdge = (rect, dir) => {\n  switch (dir) {\n    case 'left':\n      return { x: rect.left, y: (rect.top + rect.bottom) / 2 };\n    case 'right':\n      return { x: rect.right, y: (rect.top + rect.bottom) / 2 };\n    case 'up':\n      return { x: (rect.left + rect.right) / 2, y: rect.top };\n    case 'down':\n      return { x: (rect.left + rect.right) / 2, y: rect.bottom };\n  }\n};\n\n/**\n * Gets the nearest point on `rect` that a line in direction `dir` from `point` would hit\n * If the rect is exactly in direction `dir` then the point will be in a straight line from `point`.\n * Otherwise it will be the nearest corner of the target rect.\n *\n * @param {Point} point The point to start from\n * @param {String} dir The direction to draw the line in\n * @param {Object} rect An object representing the rectangle of the item we're going to\n * @return {Point} An object with the X/Y coordinates of the nearest point\n */\nconst getNearestPoint = (point, dir, rect) => {\n  if (dir === 'left' || dir === 'right') {\n    // When moving horizontally...\n    // The nearest X is always the nearest edge, left or right\n    const x = dir === 'left' ? rect.right : rect.left;\n\n    // If the start point is higher than the rect, nearest Y is the top corner\n    if (point.y < rect.top) return { x, y: rect.top };\n    // If the start point is lower than the rect, nearest Y is the bottom corner\n    if (point.y > rect.bottom) return { x, y: rect.bottom };\n    // Else the nearest Y is aligned with where we started\n    return { x, y: point.y };\n  } else if (dir === 'up' || dir === 'down') {\n    // When moving vertically...\n    // The nearest Y is always the nearest edge, top or bottom\n    const y = dir === 'up' ? rect.bottom : rect.top;\n\n    // If the start point is left-er than the rect, nearest X is the left corner\n    if (point.x < rect.left) return { x: rect.left, y };\n    // If the start point is right-er than the rect, nearest X is the right corner\n    if (point.x > rect.right) return { x: rect.right, y };\n    // Else the nearest X is aligned with where we started\n    return { x: point.x, y };\n  }\n};\n\n/**\n * Get the Pythagorean distance between two points\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {number} Distance from A to B\n */\nconst getDistanceBetweenPoints = (a, b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n\n/**\n * Check if point A is below point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is below b, false otherwise\n */\nconst isBelow = (a, b) => a.y > b.y;\n\n/**\n * Check if point A is to the right of point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is to the right of b, false otherwise\n */\nconst isRight = (a, b) => a.x > b.x;\n\n/**\n * Get blocked exit directions for current node\n *\n * @param {HTMLElement} container Current focus container\n * @param {HTMLElement} candidateContainer Candidate focus container\n * @return {string[]} Array of strings representing blocked directions\n */\nconst getBlockedExitDirs = (container, candidateContainer) => {\n  if (!container) {\n    return [];\n  }\n\n  const currentAncestorContainers = collectContainers(container);\n  const candidateAncestorContainers = collectContainers(candidateContainer);\n\n  // Find common container for current container and candidate container and\n  // remove everything above it\n  for (let i = 0; i < candidateAncestorContainers.length; i++) {\n    let commonCandidate = candidateAncestorContainers[i];\n\n    const spliceIndex = currentAncestorContainers.indexOf(commonCandidate);\n\n    if (spliceIndex > -1) {\n      currentAncestorContainers.splice(spliceIndex);\n      break;\n    }\n  }\n\n  return currentAncestorContainers.reduce((acc, cur) => {\n    const dirs = (cur?.getAttribute(DATA_BLOCK_EXIT_ATTRIBUTE) || '').split(' ');\n\n    return acc.concat(dirs);\n  }, []);\n};\n\n/**\n * Check if the candidate is in the `exitDir` direction from the rect we're leaving,\n * with an overlap allowance of entryWeighting as a percentage of the candidate's width.\n *\n * @param {Object} entryRect An object representing the rectangle of the item we're moving to\n * @param {String} exitDir The direction we're moving in\n * @param {Object} exitPoint The midpoint of the edge we're leaving\n * @param {Float} entryWeighting Percentage of the candidate that is allowed to be behind the target\n * @return {Booelan} true if candidate is in the correct dir, false if not\n */\nconst isValidCandidate = (entryRect, exitDir, exitPoint, entryWeighting) => {\n  if (entryRect.width === 0 && entryRect.height === 0) return false;\n  if (!entryWeighting && entryWeighting != 0) entryWeighting = 0.3;\n\n  const weightedEntryPoint = {\n    x: entryRect.left + (entryRect.width * (exitDir === 'left' ? 1 - entryWeighting : exitDir === 'right' ? entryWeighting : 0.5)),\n    y: entryRect.top + (entryRect.height * (exitDir === 'up' ? 1 - entryWeighting : exitDir === 'down' ? entryWeighting : 0.5))\n  };\n\n  if (\n    exitDir === 'left' && isRight(exitPoint, weightedEntryPoint) ||\n    exitDir === 'right' && isRight(weightedEntryPoint, exitPoint) ||\n    exitDir === 'up' && isBelow(exitPoint, weightedEntryPoint) ||\n    exitDir === 'down' && isBelow(weightedEntryPoint, exitPoint)\n  ) return true;\n\n  return false;\n};\n\n/**\n * Sort the candidates ordered by distance to the elem,\n * and filter out invalid candidates.\n *\n * @param {HTMLElement[]} candidates A set of candidate elements to sort\n * @param {HTMLElement} elem The search origin\n * @param {string} exitDir The direction in which we exited the elem (left, right, up, down)\n * @return {HTMLElement[]} The valid candidates, in order by distance\n */\nconst sortValidCandidates = (candidates, elem, exitDir) => {\n  const exitRect = elem.getBoundingClientRect();\n  const exitPoint = getMidpointForEdge(exitRect, exitDir);\n  return candidates.filter(candidate => {\n    // Filter out candidates that are in the opposite direction or have no dimensions\n    const entryRect = candidate.getBoundingClientRect();\n    const allowedOverlap = parseFloat(candidate.getAttribute('data-lrud-overlap-threshold'));\n    return isValidCandidate(entryRect, exitDir, exitPoint, allowedOverlap);\n  }).map(candidate => {\n    const entryRect = candidate.getBoundingClientRect();\n    const nearestPoint = getNearestPoint(exitPoint, exitDir, entryRect);\n    const distance = getDistanceBetweenPoints(exitPoint, nearestPoint);\n    return {\n      candidate,\n      distance\n    };\n  }).sort((a, b) => a.distance - b.distance).map(({ candidate }) => candidate);\n};\n\n/**\n * Get the first parent container that matches the focusable candidate selector\n * @param {HTMLElement} startingCandidate The starting candidate to get the parent container of\n * @return {HTMLElement} The container that matches or null\n */\n// const getParentFocusableContainer = (startingCandidate) => {\n//   if (!startingCandidate) return null;\n//   do {\n//     startingCandidate = getParentContainer(startingCandidate);\n//   } while (startingCandidate && !matches(startingCandidate, focusableContainerSelector));\n\n//   return startingCandidate;\n// };\n\n/**\n * Get a possible destination (if set) for a container\n * @param {HTMLElement} parentContainer The parent container\n * @return {HTMLElement | null | -1} The element that should get the focus next, (null if nothing to focus, undefined if no destinations available)\n */\nconst getPreferredDestination = (parentContainer) => {\n  // Use destinations if available to find new focus\n  const destinations = parentContainer?.getAttribute(DESTINATIONS_ATTRIBUTE);\n  if (destinations?.length) {\n    // Find the first valid element and set that as newFocus\n    const candidateIDs = destinations.split(' ');\n    let newFocus = null;\n    for (let candidateID of candidateIDs) {\n      newFocus = document.getElementById(candidateID);\n      if (newFocus) {\n        break;\n      }\n    }\n    return newFocus;\n  } else {\n    return undefined;\n  }\n};\n\n/**\n * Get one of the possible focusable candidates\n *\n * @param {HTMLElement} parentContainer Parent of the starting element (current starting point)\n * @param {HTMLElement[]} focusableCandidates Possible candiadates list to choose from\n * @param {string} exitDir Direction requested\n * @param {boolean} blockSetExits If true, blocks exits based on data-block-exits\n * @return {HTMLElement|null} candidate that gets the next focus or null if nothing valid found\n */\n\nconst getNextFromCandidates = (parentContainer, focusableCandidates, exitDir, blockSetExits) => {\n  for (const candidate of focusableCandidates) {\n    const candidateIsContainer = matches(candidate, containerSelector);\n    const candidateContainer = candidateIsContainer ? candidate : getParentContainer(candidate);\n\n    const isCurrentContainer = candidateContainer === parentContainer;\n    const isNestedContainer = parentContainer?.contains(candidateContainer);\n    const isAnscestorContainer = candidateContainer?.contains(parentContainer);\n\n    if (!isCurrentContainer && (!isNestedContainer || candidateIsContainer)) {\n      if (blockSetExits) {\n        const blockedExitDirs = getBlockedExitDirs(parentContainer, candidateContainer);\n        if (blockedExitDirs.indexOf(exitDir) > -1) continue; // TODO: should we stop searching here?\n      }\n\n      if (candidateContainer && !isAnscestorContainer) {\n        if (candidateIsContainer) {\n          const candidateContainerAutoFocus = candidateContainer?.getAttribute(AUTOFOCUS_ATTRIBUTE) === 'true';\n          if (candidateContainerAutoFocus) {\n            // 1. Use destinations (if available) to find new focus\n            const destination = getPreferredDestination(candidateContainer);\n            if (destination !== undefined && destination !== null) {\n                candidateContainer?.setAttribute(DATA_FOCUS_ATTRIBUTE, destination?.id);\n                // TODO: What if destination is a container!!\n                return destination;\n            }\n            // 2. Use last active child\n            const lastActiveChild = document.getElementById(candidateContainer?.getAttribute(DATA_FOCUS_ATTRIBUTE));\n            if (lastActiveChild) {\n              return lastActiveChild;\n            }\n            // For now not resetting the data-focus here...\n          }\n        }\n        // find default focus\n        const newFocus = getFocusables(candidateContainer)?.[0];\n        // Container may be empty or another Container\n        if (!newFocus || matches(newFocus, containerSelector)) {\n          continue;\n        }\n        // getParentFocusableContainer(candidateContainer)?.setAttribute(DATA_FOCUS_ATTRIBUTE, newFocus?.id);\n\n        candidateContainer?.setAttribute(DATA_FOCUS_ATTRIBUTE, getId(newFocus));\n        return newFocus;\n      }\n    }\n    if (!candidateIsContainer) {\n      // getParentFocusableContainer(candidateContainer)?.setAttribute(DATA_FOCUS_ATTRIBUTE, candidate.id);\n      candidateContainer?.setAttribute(DATA_FOCUS_ATTRIBUTE, getId(candidate));\n    }\n    return candidate;\n  }\n  // If here, nothing could be found\n  return null;\n};\n\n/**\n * Get the next focus candidate\n *\n * @param {HTMLElement} elem The search origin\n * @param {string|number} keyOrKeyCode The key or keyCode value (from KeyboardEvent) of the pressed key\n * @param {HTMLElement} scope The element LRUD spatial is scoped to operate within\n * @return {HTMLElement} The element that should receive focus next\n */\nexport const getNextFocus = (elem, keyOrKeyCode, scope) => {\n  if (!scope || !scope.querySelector) scope = document.body;\n  if (!elem) return getFocusables(scope)?.[0];\n  const exitDir = _keyMap[keyOrKeyCode];\n  let nextFocus = null;\n\n  // Get parent focus container\n  const parentContainer = getParentContainer(elem);\n  // if (parentContainer && matches(elem, focusableSelector)) {\n  //   parentContainer.setAttribute(DATA_FOCUS_ATTRIBUTE, getId(elem));\n  //   // getParentFocusableContainer(parentContainer)?.setAttribute(DATA_FOCUS_ATTRIBUTE, elem.id);\n  // }\n\n  let focusableCandidates = [];\n\n  // Get all siblings within a prioritised container\n  if (parentContainer?.getAttribute(PRIORITISE_CHILDREN_ATTRIBUTE)?.valueOf() === 'true' && scope.contains(parentContainer)) {\n    const focusableSiblings = getAllFocusables(parentContainer);\n    focusableCandidates = sortValidCandidates(focusableSiblings, elem, exitDir);\n  }\n\n  if (focusableCandidates.length) {\n    // First only look for next focus in same parent\n    nextFocus = getNextFromCandidates(parentContainer, focusableCandidates, exitDir, true);\n    if (nextFocus) {\n      return nextFocus;\n    }\n  }\n\n  // Cound not find anything in the same parent continer, expand the search\n  const candidates = getAllFocusables(scope);\n  focusableCandidates = sortValidCandidates(candidates, elem, exitDir);\n  nextFocus = getNextFromCandidates(parentContainer, focusableCandidates, exitDir, false);\n  if (nextFocus) {\n    return nextFocus;\n  }\n\n  // If here nothing could be found!!\n  return nextFocus;\n};"],"mappings":"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","ignoreList":[]}