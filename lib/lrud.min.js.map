{"version":3,"file":"lrud.min.js","names":["focusableSelector","containerSelector","ignoreSelector","DESTINATIONS_ATTRIBUTE","DATA_BLOCK_EXIT_ATTRIBUTE","DATA_AUTOFOCUS_ATTRIBUTE","DATA_FOCUS_ATTRIBUTE","_left","_right","_up","_down","_keyMap","createMissingId","setConfig","exports","config","keyMap","getId","element","_element$id","id","length","matches","selectors","console","warn","fn","Element","prototype","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","s","document","ownerDocument","querySelectorAll","i","item","call","toArray","nodeList","Array","slice","getParentContainer","elem","parentElement","tagName","getFocusables","scope","ignoredElements","filter","node","some","ignored","contains","parseInt","getAttribute","getDefaultFocus","focus","focusables","parentContainer","getPreferredDestination","undefined","_focus","setAttribute","getElementById","getAllFocusables","concat","collectContainers","initialContainer","acc","cur","push","getMidpointForEdge","rect","dir","x","left","y","top","bottom","right","getNearestPoint","point","getDistanceBetweenPoints","a","b","Math","sqrt","pow","isBelow","isRight","getBlockedExitDirs","container","candidateContainer","currentAncestorContainers","candidateAncestorContainers","commonCandidate","spliceIndex","indexOf","splice","reduce","dirs","split","isValidCandidate","entryRect","exitDir","exitPoint","entryWeighting","width","height","weightedEntryPoint","sortValidCandidates","candidates","exitRect","getBoundingClientRect","candidate","allowedOverlap","parseFloat","map","nearestPoint","distance","sort","_ref","destinations","candidateIDs","newFocus","_iterator","_createForOfIteratorHelper","_step","n","done","candidateID","value","err","e","f","getNextFromCandidates","focusableCandidates","blockSetExits","_iterator2","_step2","candidateIsContainer","isCurrentContainer","isNestedContainer","isAnscestorContainer","candidateContainerAutoFocus","blockedExitDirs","_getFocusables","destination","log","getNextFocus","keyOrKeyCode","querySelector","body","nextFocus"],"sources":["lrud.js"],"sourcesContent":["/**\n * LRUD: Spatial Edition\n *\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *  @@@@@@      '@@@@@@@@@   @@@@@@      '@@@@@@@@@   @@@@@@@@      '@@@@@@@\n *  @@@@@@  @@.   @@@@@@@@   @@@@@@  @@.    @@@@@@@   @@@@@     @@@@.   @@@@\n *  @@@@@@  @@@@  @@@@@@@@   @@@@@@  @@@@   @@@@@@@   @@@@   @@@@@@@@@@@@@@@\n *  @@@@@@        @@@@@@@@   @@@@@@        @@@@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@.  @@@@@@   @@@@@@  @@@@@.  @@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@   @@@@@@   @@@@@@  @@@@@   @@@@@@   @@@@    @@@@@@@@/ @@@@\n *  @@@@@@        /@@@@@@@   @@@@@@        /@@@@@@@   @@@@@@\\,         @@@@@\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *\n * Copyright (C) 2023 BBC.\n */\n\n// Any \"interactive content\" https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Interactive_content\nconst focusableSelector = '[tabindex], a, input, button';\nconst containerSelector = 'nav, section, .lrud-container'; // TODO: Do we need nav and section here anymore??\n// const focusableContainerSelector = '[data-lrud-consider-container-distance]'; // Manage using just the containerSelector\nconst ignoreSelector = '.lrud-ignore, [disabled]';\nconst DESTINATIONS_ATTRIBUTE = 'data-destinations';\nconst DATA_BLOCK_EXIT_ATTRIBUTE = 'data-block-exit';\nconst DATA_AUTOFOCUS_ATTRIBUTE = 'data-autofocus';\nconst DATA_FOCUS_ATTRIBUTE = 'data-focus';\n// const PRIORITISE_CHILDREN_ATTRIBUTE = 'data-lrud-prioritise-children'; // Only set when data-block-exit are set\n\n/**\n * This is how the React Native Web TV props are mapped here:\n *\n * 1. TVFocusGuideView.tvFocusable={true}  -> .lrud-container\n *    Rest of the attributes and logic for TVFocusGuideView is only valid if tvFocusable is true\n * 2. TVFocusGuideView.focusable={false} -> set .lrud-ignore : Ignores all elements under .lrud-container for focus logic\n * 3. TVFocusGuideView.autoFocus={true} -> data-autofocus attribute is 'true'/'false'. The attributes data-destinations and\n *    data-focus parent containers should only be applied when data-focus is true. Same for data-block-exit??\n * 4. TVFocusGuideView.trapFocusUp={true} -> data-block-exit=\"up\"\n * 5. TVFocusGuideView.trapFocusDown={true} -> data-block-exit=\"down\"\n * 6. TVFocusGuideView.trapFocusLeft={true} -> data-block-exit=\"left\"\n * 7. TVFocusGuideView.trapFocusRight={true} -> data-block-exit=\"right\"\n * 8. TVFocusGuideView.destinations=[\"id1\", \"id2\"] -> data-destinations=\"id1 id2\": These ids are from\n *    id assigned to each of the destination elements.\n *\n * Any other compoenents are navigated using the default lrud algorithm based on tabindex and role of elements.\n */\n\nconst _left = 'left', _right = 'right', _up = 'up', _down = 'down';\nlet _keyMap = {\n  4: _left,\n  21: _left,\n  37: _left,\n  214: _left,\n  205: _left,\n  218: _left,\n  5: _right,\n  22: _right,\n  39: _right,\n  213: _right,\n  206: _right,\n  217: _right,\n  29460: _up,\n  19: _up,\n  38: _up,\n  211: _up,\n  203: _up,\n  215: _up,\n  29461: _down,\n  20: _down,\n  40: _down,\n  212: _down,\n  204: _down,\n  216: _down,\n  'ArrowLeft': _left,\n  'ArrowRight': _right,\n  'ArrowUp': _up,\n  'ArrowDown': _down\n};\n\nlet createMissingId = null;\n\nexport const setConfig = (config) => {\n  _keyMap = config.keyMap || _keyMap;\n  createMissingId = typeof config.createMissingId === 'function' ? config.createMissingId : null;\n};\n\nconst getId = (element) => (element.id && element.id?.length) ? element.id : createMissingId ? createMissingId(element) : '';\n\n/**\n * Element API .matches() with fallbacks\n */\nconst matches = (element, selectors) => {\n  if (!element) {\n    console.warn('matches() passed with a null element');\n    return false;\n  }\n  const fn = Element.prototype.matches ||\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector ||\n    function(s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n        i = matches.length;\n      // eslint-disable-next-line no-empty\n      while (--i >= 0 && matches.item(i) !== this) {}\n      return i > -1;\n    };\n\n  return fn.call(element, selectors);\n};\n\n/**\n * Convert a NodeList to a regular Array\n *\n * @param {NodeList} nodeList The NodeList representation\n * @return {Array|null} The Array representation\n */\nconst toArray = (nodeList) => Array.prototype.slice.call(nodeList);\n\n/**\n * Traverse DOM ancestors until we find a focus container\n *\n * @param {HTMLElement} elem The element representing the search origin\n * @return {HTMLElement|null} The parent focus container or null\n */\nconst getParentContainer = (elem) => {\n  if (!elem.parentElement || elem.parentElement.tagName === 'BODY') {\n    return null;\n  } else if (matches(elem.parentElement, containerSelector)) {\n    return elem.parentElement;\n  }\n\n  return getParentContainer(elem.parentElement);\n};\n\n/**\n * Get all focusable elements inside `scope`,\n * discounting any that are ignored or inside an ignored container\n *\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getFocusables = (scope) => {\n  if (!scope) return [];\n\n  const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n  return toArray(scope.querySelectorAll(focusableSelector))\n    .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n    .filter(node => matches(node, containerSelector) || parseInt(node.getAttribute('tabindex') || '0', 10) > -1);\n};\n\n/**\n * Get first focusable element as a default focus inside a 'scope\n *\n * @param {HTMLElement} scope The element to search inside of\n *\n * @return {HTMLElement|null} First fucusable HTML Element\n */\nconst getDefaultFocus = (scope) => {\n  let focus = null;\n  const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n  const focusables = toArray(scope.querySelectorAll(focusableSelector))\n    .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n    .filter(node => parseInt(node.getAttribute('tabindex') || '0', 10) > -1);\n\n  focus = focusables?.[0];\n  const parentContainer = getParentContainer(focusables?.[0]);\n  if (parentContainer) {\n    focus = getPreferredDestination(parentContainer);\n    if (focus !== undefined && focus !== null) {\n      parentContainer?.setAttribute(DATA_FOCUS_ATTRIBUTE, focus?.id);\n      return focus;\n    }\n\n    focus = document.getElementById(parentContainer?.getAttribute(DATA_FOCUS_ATTRIBUTE));\n    if (focus) {\n      return focus;\n    }\n  }\n  return focusables?.[0];\n};\n\n/**\n * Get all the focusable candidates inside `scope`,\n * including focusable containers\n *\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getAllFocusables = (scope) =>\n  // const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n    [\n    // ...toArray(scope.querySelectorAll(focusableContainerSelector))\n      // .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n      // .filter(container => getFocusables(container)?.length > 0),\n    ...getFocusables(scope)\n  ];\n\n/**\n * Build an array of ancestor containers\n *\n * @param {HTMLElement} initialContainer The container to start from\n * @return {HTMLElement[]} An array of ancestor containers\n */\nconst collectContainers = (initialContainer) => {\n  if (!initialContainer) return [];\n  const acc = [ initialContainer ];\n  let cur = initialContainer;\n  while (cur) {\n    cur = getParentContainer(cur);\n    if (cur) acc.push(cur);\n  }\n  return acc;\n};\n\n/**\n * Get the middle point of a given edge\n *\n * @param {Object} rect An object representing the rectangle\n * @param {String} dir The direction of the edge (left, right, up, down)\n * @return {Point} An object with the X and Y coordinates of the point\n */\nconst getMidpointForEdge = (rect, dir) => {\n  switch (dir) {\n    case 'left':\n      return { x: rect.left, y: (rect.top + rect.bottom) / 2 };\n    case 'right':\n      return { x: rect.right, y: (rect.top + rect.bottom) / 2 };\n    case 'up':\n      return { x: (rect.left + rect.right) / 2, y: rect.top };\n    case 'down':\n      return { x: (rect.left + rect.right) / 2, y: rect.bottom };\n  }\n};\n\n/**\n * Gets the nearest point on `rect` that a line in direction `dir` from `point` would hit\n * If the rect is exactly in direction `dir` then the point will be in a straight line from `point`.\n * Otherwise it will be the nearest corner of the target rect.\n *\n * @param {Point} point The point to start from\n * @param {String} dir The direction to draw the line in\n * @param {Object} rect An object representing the rectangle of the item we're going to\n * @return {Point} An object with the X/Y coordinates of the nearest point\n */\nconst getNearestPoint = (point, dir, rect) => {\n  if (dir === 'left' || dir === 'right') {\n    // When moving horizontally...\n    // The nearest X is always the nearest edge, left or right\n    const x = dir === 'left' ? rect.right : rect.left;\n\n    // If the start point is higher than the rect, nearest Y is the top corner\n    if (point.y < rect.top) return { x, y: rect.top };\n    // If the start point is lower than the rect, nearest Y is the bottom corner\n    if (point.y > rect.bottom) return { x, y: rect.bottom };\n    // Else the nearest Y is aligned with where we started\n    return { x, y: point.y };\n  } else if (dir === 'up' || dir === 'down') {\n    // When moving vertically...\n    // The nearest Y is always the nearest edge, top or bottom\n    const y = dir === 'up' ? rect.bottom : rect.top;\n\n    // If the start point is left-er than the rect, nearest X is the left corner\n    if (point.x < rect.left) return { x: rect.left, y };\n    // If the start point is right-er than the rect, nearest X is the right corner\n    if (point.x > rect.right) return { x: rect.right, y };\n    // Else the nearest X is aligned with where we started\n    return { x: point.x, y };\n  }\n};\n\n/**\n * Get the Pythagorean distance between two points\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {number} Distance from A to B\n */\nconst getDistanceBetweenPoints = (a, b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n\n/**\n * Check if point A is below point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is below b, false otherwise\n */\nconst isBelow = (a, b) => a.y > b.y;\n\n/**\n * Check if point A is to the right of point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is to the right of b, false otherwise\n */\nconst isRight = (a, b) => a.x > b.x;\n\n/**\n * Get blocked exit directions for current node\n *\n * @param {HTMLElement} container Current focus container\n * @param {HTMLElement} candidateContainer Candidate focus container\n * @return {string[]} Array of strings representing blocked directions\n */\nconst getBlockedExitDirs = (container, candidateContainer) => {\n  if (!container) {\n    return [];\n  }\n\n  const currentAncestorContainers = collectContainers(container);\n  const candidateAncestorContainers = collectContainers(candidateContainer);\n\n  // Find common container for current container and candidate container and\n  // remove everything above it\n  for (let i = 0; i < candidateAncestorContainers.length; i++) {\n    let commonCandidate = candidateAncestorContainers[i];\n\n    const spliceIndex = currentAncestorContainers.indexOf(commonCandidate);\n\n    if (spliceIndex > -1) {\n      currentAncestorContainers.splice(spliceIndex);\n      break;\n    }\n  }\n\n  return currentAncestorContainers.reduce((acc, cur) => {\n    const dirs = (cur?.getAttribute(DATA_BLOCK_EXIT_ATTRIBUTE) || '').split(' ');\n\n    return acc.concat(dirs);\n  }, []);\n};\n\n/**\n * Check if the candidate is in the `exitDir` direction from the rect we're leaving,\n * with an overlap allowance of entryWeighting as a percentage of the candidate's width.\n *\n * @param {Object} entryRect An object representing the rectangle of the item we're moving to\n * @param {String} exitDir The direction we're moving in\n * @param {Object} exitPoint The midpoint of the edge we're leaving\n * @param {Float} entryWeighting Percentage of the candidate that is allowed to be behind the target\n * @return {Booelan} true if candidate is in the correct dir, false if not\n */\nconst isValidCandidate = (entryRect, exitDir, exitPoint, entryWeighting) => {\n  if (entryRect.width === 0 && entryRect.height === 0) return false;\n  if (!entryWeighting && entryWeighting != 0) entryWeighting = 0.3;\n\n  const weightedEntryPoint = {\n    x: entryRect.left + (entryRect.width * (exitDir === 'left' ? 1 - entryWeighting : exitDir === 'right' ? entryWeighting : 0.5)),\n    y: entryRect.top + (entryRect.height * (exitDir === 'up' ? 1 - entryWeighting : exitDir === 'down' ? entryWeighting : 0.5))\n  };\n\n  if (\n    exitDir === 'left' && isRight(exitPoint, weightedEntryPoint) ||\n    exitDir === 'right' && isRight(weightedEntryPoint, exitPoint) ||\n    exitDir === 'up' && isBelow(exitPoint, weightedEntryPoint) ||\n    exitDir === 'down' && isBelow(weightedEntryPoint, exitPoint)\n  ) return true;\n\n  return false;\n};\n\n/**\n * Sort the candidates ordered by distance to the elem,\n * and filter out invalid candidates.\n *\n * @param {HTMLElement[]} candidates A set of candidate elements to sort\n * @param {HTMLElement} elem The search origin\n * @param {string} exitDir The direction in which we exited the elem (left, right, up, down)\n * @return {HTMLElement[]} The valid candidates, in order by distance\n */\nconst sortValidCandidates = (candidates, elem, exitDir) => {\n  const exitRect = elem.getBoundingClientRect();\n  const exitPoint = getMidpointForEdge(exitRect, exitDir);\n  return candidates.filter(candidate => {\n    // Filter out candidates that are in the opposite direction or have no dimensions\n    const entryRect = candidate.getBoundingClientRect();\n    const allowedOverlap = parseFloat(candidate.getAttribute('data-lrud-overlap-threshold'));\n    return isValidCandidate(entryRect, exitDir, exitPoint, allowedOverlap);\n  }).map(candidate => {\n    const entryRect = candidate.getBoundingClientRect();\n    const nearestPoint = getNearestPoint(exitPoint, exitDir, entryRect);\n    const distance = getDistanceBetweenPoints(exitPoint, nearestPoint);\n    return {\n      candidate,\n      distance\n    };\n  }).sort((a, b) => a.distance - b.distance).map(({ candidate }) => candidate);\n};\n\n/**\n * Get the first parent container that matches the focusable candidate selector\n * @param {HTMLElement} startingCandidate The starting candidate to get the parent container of\n * @return {HTMLElement} The container that matches or null\n */\n// const getParentFocusableContainer = (startingCandidate) => {\n//   if (!startingCandidate) return null;\n//   do {\n//     startingCandidate = getParentContainer(startingCandidate);\n//   } while (startingCandidate && !matches(startingCandidate, focusableContainerSelector));\n\n//   return startingCandidate;\n// };\n\n/**\n * Get a possible destination (if set) for a container\n * @param {HTMLElement} parentContainer The parent container\n * @return {HTMLElement | null | -1} The element that should get the focus next, (null if nothing to focus, undefined if no destinations available)\n */\nconst getPreferredDestination = (parentContainer) => {\n  // Use destinations if available to find new focus\n  const destinations = parentContainer?.getAttribute(DESTINATIONS_ATTRIBUTE);\n  if (destinations?.length) {\n    // Find the first valid element and set that as newFocus\n    const candidateIDs = destinations.split(' ');\n    let newFocus = null;\n    for (let candidateID of candidateIDs) {\n      newFocus = document.getElementById(candidateID);\n      if (newFocus) {\n        break;\n      }\n    }\n    return newFocus;\n  } else {\n    return undefined;\n  }\n};\n\n/**\n * Get one of the possible focusable candidates\n *\n * @param {HTMLElement} parentContainer Parent of the starting element (current starting point)\n * @param {HTMLElement[]} focusableCandidates Possible candiadates list to choose from\n * @param {string} exitDir Direction requested\n * @param {boolean} blockSetExits If true, blocks exits based on data-block-exits\n * @return {HTMLElement|null} candidate that gets the next focus or null if nothing valid found\n */\n\nconst getNextFromCandidates = (parentContainer, focusableCandidates, exitDir, blockSetExits) => {\n  for (const candidate of focusableCandidates) {\n    const candidateIsContainer = matches(candidate, containerSelector);\n    const candidateContainer = candidateIsContainer ? candidate : getParentContainer(candidate);\n\n    const isCurrentContainer = candidateContainer === parentContainer;\n    const isNestedContainer = parentContainer?.contains(candidateContainer);\n    const isAnscestorContainer = candidateContainer?.contains(parentContainer);\n\n    const candidateContainerAutoFocus = candidateContainer?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n\n    // !isCurrentContainer:\n    //   - If new Candidate is a container, it should not be a parent of starting point (current focus)\n    //   - If new Candidate is not a container, it should not a sibling of starting point (current focus)\n    // AND\n    // (2a. !isNestedContainer:\n    //   - If new Candidate is a container, it should not be contained in starting point's parent\n    //   - If new Candidate is not a container, it's parent should not be contained in starting point's parent\n    // OR\n    // 2b.) candidateIsContainer\n    //   - If new Candidate is a container\n    if (!isCurrentContainer && (!isNestedContainer || candidateIsContainer)) {\n      if (blockSetExits) {\n        const blockedExitDirs = getBlockedExitDirs(parentContainer, candidateContainer);\n        if (blockedExitDirs.indexOf(exitDir) > -1) {\n          return null;\n        }\n      }\n\n      // !isAncestorContainer\n      //   - If new Candidate is a container, it should not contain the starting point's parent\n      //   - If new Candidate is not a container, it's parent should not contain the starting point's parent\n      if (candidateContainer && !isAnscestorContainer) {\n        if (candidateIsContainer) {\n          if (candidateContainerAutoFocus) {\n            // 1. Use destinations (if available) to find new focus\n            const destination = getPreferredDestination(candidateContainer);\n            if (destination !== undefined && destination !== null) {\n                candidateContainer?.setAttribute(DATA_FOCUS_ATTRIBUTE, destination?.id);\n                // TODO: What if destination is a container!!\n                return destination;\n            }\n            // 2. Use last known active child\n            let newFocus = document.getElementById(candidateContainer?.getAttribute(DATA_FOCUS_ATTRIBUTE));\n            if (newFocus) {\n              return newFocus;\n            }\n            // 3. Find a default one\n            newFocus = getFocusables(candidateContainer)?.[0];\n            // Container may be empty or another Container\n            if (!newFocus || matches(newFocus, containerSelector)) {\n              // assuming the focusable container will be in focusableCandidates\n              continue;\n            }\n            // getParentFocusableContainer(candidateContainer)?.setAttribute(DATA_FOCUS_ATTRIBUTE, newFocus?.id);\n            candidateContainer?.setAttribute(DATA_FOCUS_ATTRIBUTE, getId(newFocus));\n            return newFocus;\n          } else {\n            // Don't use Container attributes to decide\n            continue;\n          }\n        } else {\n          console.log('Candidate is NOT Container: ', candidate);\n        }\n      } else {\n        console.log('Did not enter: candidateContainer && !isAnscestorContainer: ', candidate);\n      }\n    } else {\n      console.log('Did not enter: (!isCurrentContainer && (!isNestedContainer || candidateIsContainer)): ', candidate);\n    }\n    if (!candidateIsContainer && candidateContainerAutoFocus) {\n      // getParentFocusableContainer(candidateContainer)?.setAttribute(DATA_FOCUS_ATTRIBUTE, candidate.id);\n      candidateContainer?.setAttribute(DATA_FOCUS_ATTRIBUTE, getId(candidate));\n    }\n    return candidate;\n  }\n  // If here, nothing could be found\n  return null;\n};\n\n/**\n * Get the next focus candidate\n *\n * @param {HTMLElement} elem The search origin\n * @param {string|number} keyOrKeyCode The key or keyCode value (from KeyboardEvent) of the pressed key\n * @param {HTMLElement} scope The element LRUD spatial is scoped to operate within\n * @return {HTMLElement} The element that should receive focus next\n */\nexport const getNextFocus = (elem, keyOrKeyCode, scope) => {\n  if (!scope || !scope.querySelector) scope = document.body;\n  if (!elem) return getDefaultFocus(scope);\n  const exitDir = _keyMap[keyOrKeyCode];\n  let nextFocus = null;\n\n  // Get parent focus container\n  const parentContainer = getParentContainer(elem);\n  // if (parentContainer && matches(elem, focusableSelector)) {\n  //   parentContainer.setAttribute(DATA_FOCUS_ATTRIBUTE, getId(elem));\n  //   // getParentFocusableContainer(parentContainer)?.setAttribute(DATA_FOCUS_ATTRIBUTE, elem.id);\n  // }\n\n  let focusableCandidates = [];\n\n  if (parentContainer) {\n    // First look into current container only as sortValidCandidates works only on the basis of\n    // container bounding rectangles, which may not necessarily be physically bounding it's children\n    const candidates = getAllFocusables(parentContainer);\n    focusableCandidates = sortValidCandidates(candidates, elem, exitDir);\n    if (focusableCandidates.length) {\n      nextFocus = getNextFromCandidates(parentContainer, focusableCandidates, exitDir, false);\n    }\n  }\n\n  if (focusableCandidates.length === 0) {\n    const candidates = getAllFocusables(scope);\n    focusableCandidates = sortValidCandidates(candidates, elem, exitDir);\n    nextFocus = getNextFromCandidates(parentContainer, focusableCandidates, exitDir, true);\n    if (nextFocus) {\n      return nextFocus;\n    }\n  }\n  // If here nothing could be found!!\n  return nextFocus;\n};"],"mappings":"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","ignoreList":[]}