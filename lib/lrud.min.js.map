{"version":3,"file":"lrud.min.js","names":["focusableSelector","containerSelector","ignoreSelector","DESTINATIONS_ATTRIBUTE","DATA_BLOCK_EXIT_ATTRIBUTE","DATA_AUTOFOCUS_ATTRIBUTE","DATA_FOCUS_ATTRIBUTE","_left","_right","_up","_down","_keyMap","setConfig","exports","config","keyMap","hasDOM","window","document","Element","matchesFunction","prototype","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","s","ownerDocument","querySelectorAll","i","length","item","element","selectors","console","warn","call","toArray","nodeList","Array","slice","getParentContainer","elem","parentElement","tagName","getFocusables","scope","_focusables2","ignoredElements","focusables","filter","node","some","ignored","contains","parseInt","getAttribute","_focusables","childrenToIgnore","Set","forEach","_node$getAttribute","hasAutoFocus","hasDestinations","allChildren","child","add","size","_focusables3","has","getDefaultFocus","exitDir","nextFocus","parentHasAutofocus","candidates","getAllFocusables","candidate","candidateIsContainer","findDestinationOrAutofocus","concat","getMidpointForEdge","rect","dir","x","left","y","top","bottom","right","getNearestPoint","point","getDistanceBetweenPoints","a","b","Math","sqrt","pow","isBelow","isRight","isValidCandidate","entryRect","exitPoint","entryWeighting","width","height","weightedEntryPoint","sortValidCandidates","exitRect","getBoundingClientRect","allowedOverlap","parseFloat","map","nearestPoint","distance","sort","_ref","getPreferredDestination","parentContainer","destinations","candidateIDs","split","newFocus","_iterator","_createForOfIteratorHelper","_step","n","done","candidateID","value","getElementById","err","e","f","undefined","candidateContainer","destination","_sortValidCandidates","candidateContainerFocusables","getNextFromCandidates","focusableCandidates","originContainer","blockExits","allowBlockExits","includes","_iterator2","_step2","candidatesContainer","_getParentContainer2","getNextFocus","keyOrKeyCode","querySelector","body"],"sources":["lrud.js"],"sourcesContent":["/**\n * LRUD: Spatial Edition\n *\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *  @@@@@@      '@@@@@@@@@   @@@@@@      '@@@@@@@@@   @@@@@@@@      '@@@@@@@\n *  @@@@@@  @@.   @@@@@@@@   @@@@@@  @@.    @@@@@@@   @@@@@     @@@@.   @@@@\n *  @@@@@@  @@@@  @@@@@@@@   @@@@@@  @@@@   @@@@@@@   @@@@   @@@@@@@@@@@@@@@\n *  @@@@@@        @@@@@@@@   @@@@@@        @@@@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@.  @@@@@@   @@@@@@  @@@@@.  @@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@   @@@@@@   @@@@@@  @@@@@   @@@@@@   @@@@    @@@@@@@@/ @@@@\n *  @@@@@@        /@@@@@@@   @@@@@@        /@@@@@@@   @@@@@@\\,         @@@@@\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *\n * Copyright (C) 2023 BBC.\n */\n\n// Any \"interactive content\" https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Interactive_content\nconst focusableSelector = '[tabindex], a, input, button';\nconst containerSelector = 'nav, section, .lrud-container'; // TODO: Do we need nav and section here anymore??\n// const focusableContainerSelector = '[data-lrud-consider-container-distance]'; // Manage using just the containerSelector\nconst ignoreSelector = '.lrud-ignore, [disabled]';\nconst DESTINATIONS_ATTRIBUTE = 'data-destinations';\nconst DATA_BLOCK_EXIT_ATTRIBUTE = 'data-block-exit';\nconst DATA_AUTOFOCUS_ATTRIBUTE = 'data-autofocus';\nconst DATA_FOCUS_ATTRIBUTE = 'data-focus';\n// const PRIORITISE_CHILDREN_ATTRIBUTE = 'data-lrud-prioritise-children'; // Only set when data-block-exit are set\n\n/**\n * This is how the React Native Web TV props are mapped here:\n *\n * 1. TVFocusGuideView.tvFocusable={true} OR container={true} -> .lrud-container (tabindex=-1)\n *    (at the moment when TVFocusGuideView is used, looks like the directional navigation prioritises it's children irrespective of\n *    the value of tvFocusable prop. So we are mapping container={true} to .lrud-container as well)\n *    Rest of the attributes and logic for TVFocusGuideView is only valid if .lrud-container is present.\n * 2. TVFocusGuideView.focusable={false} -> sets .lrud-ignore : Ignores .lrud-container and it's children for LRUD logic\n * 3. TVFocusGuideView.autoFocus={true} -> data-autofocus attribute is 'true'/'false'. The attribute controls whether\n *    data-focus in parent containers should be applied or not. And stores last focused child in data-focus attribute.\n * 4. TVFocusGuideView.destinations=[\"id1\", \"id2\"] -> data-destinations=\"id1 id2\": These ids are from\n *    id assigned to each of the destination elements. This overrides data-focus logic (whether present or not).\n * 5. TVFocusGuideView.trapFocusUp={true} -> data-block-exit=\"up\"\n * 6. TVFocusGuideView.trapFocusDown={true} -> data-block-exit=\"down\"\n * 7. TVFocusGuideView.trapFocusLeft={true} -> data-block-exit=\"left\"\n * 8. TVFocusGuideView.trapFocusRight={true} -> data-block-exit=\"right\"\n *\n * Rules:\n * - For the first time focus:\n *  1. Default rule is to focus the first focusable element in the DOM tree order.\n *  2. If that element is in a .lrud-container and that container has data-autofocus=\"true\", then:\n *   a. If that container has data-destinations, first valid element from that list is focused.\n *   b. Else if that container has data-focus set to a valid element id, that element is focused.\n *   c. Else first focusable element as per LRUD logic is focused: On Android TV this seems to be the one closest to top-left corner of the container/window.\n *\n * - Candidates selection on directional navigation:\n *  1. The selection is influenced by the direction of the navigation (up, down, left, right).\n *  2. Candidates are selected based on their proximity to the currently focused element.\n *  3. All elements with tabindex>=0 are considered as candidates by default (with some exceptions as described below).\n *  4. The candidate search is container within the scope first (if provided).\n *  3. All elements with tabindex=\"-1\" are ignored unless they are .lrud-container elements (which requires special logic as described below).\n *  4. All elements with .lrud-ignore class or disabled attribute are ignored along with their children.\n *  5. If an element is a .lrud-container with data-autofocus=\"true\"\n *     - AND the current focus is NOT inside that container\n *       - the container itself becomes a candidate and it's children are ignored.\n *  6. If an element is a .lrud-container with data-autofocus=\"true\"\n *     - AND the current focus is outside that container\n *       - the container's children as considered as candidates and container itself is ignored.\n *\n * - Focus selection from candidates:\n * 1. From the list of candidates, the one that is closest to the current focus in the requested direction is selected.\n * 2. If the selected candidate is a .lrud-container with data-autofocus=\"true\", the following logic is applied to determine the actual focus:\n *   a. If the container has data-destinations, the first valid element from that list is focused.\n *   b. Else if the container has data-focus set to a valid element id, that element is focused.\n *   c. Else the first focusable element inside the container is focused.\n * 3. If the selected candidate is not a .lrud-container, and does not have data-autofocus=\"true\", the container is returned.\n * 4. If no valid candidate is found, null is returned.\n *\n * This module does not have a state of it's own. It relies on the DOM structure and attributes\n * to determine the next focusable element. It does not manage focus itself. If it successfully finds a new focus element,\n * it returns that element and details if that element is a container with data-autofocus=\"true\".\n * The calling code is responsible for actually setting the focus to that element.\n */\n\nconst _left = 'left', _right = 'right', _up = 'up', _down = 'down';\nlet _keyMap = {\n  4: _left,\n  21: _left,\n  37: _left,\n  214: _left,\n  205: _left,\n  218: _left,\n  5: _right,\n  22: _right,\n  39: _right,\n  213: _right,\n  206: _right,\n  217: _right,\n  29460: _up,\n  19: _up,\n  38: _up,\n  211: _up,\n  203: _up,\n  215: _up,\n  29461: _down,\n  20: _down,\n  40: _down,\n  212: _down,\n  204: _down,\n  216: _down,\n  'ArrowLeft': _left,\n  'ArrowRight': _right,\n  'ArrowUp': _up,\n  'ArrowDown': _down\n};\n\nexport const setConfig = (config) => {\n  _keyMap = config.keyMap || _keyMap;\n};\n\nconst hasDOM = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof Element !== 'undefined';\n\n// Element.matches() with fallbacks for older browsers\nconst matchesFunction = hasDOM && (window.Element.prototype.matches ||\n  window.Element.prototype.matchesSelector ||\n  window.Element.prototype.mozMatchesSelector ||\n  window.Element.prototype.msMatchesSelector ||\n  window.Element.prototype.oMatchesSelector) ||\n  function(s) {\n    var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n      i = matches.length;\n    // eslint-disable-next-line no-empty\n    while (--i >= 0 && matches.item(i) !== this) {}\n    return i > -1;\n  };\n\n/**\n * Element API .matches() with fallbacks\n */\nconst matches = (element, selectors) => {\n  if (!element) {\n    console.warn('matches() passed with a null element');\n    return false;\n  }\n\n  return matchesFunction.call(element, selectors);\n};\n\n/**\n * Convert a NodeList to a regular Array\n *\n * @param {NodeList} nodeList The NodeList representation\n * @return {Array|null} The Array representation\n */\nconst toArray = (nodeList) => Array.prototype.slice.call(nodeList);\n\n/**\n * Traverse DOM ancestors until we find a focus container\n *\n * @param {HTMLElement} elem The element representing the search origin\n * @return {HTMLElement|null} The parent focus container or null\n */\nexport const getParentContainer = (elem) => {\n  if (!elem.parentElement || elem.parentElement.tagName === 'BODY') {\n    return null;\n  } else if (matches(elem.parentElement, containerSelector)) {\n    return elem.parentElement;\n  }\n\n  return getParentContainer(elem.parentElement);\n};\n\n/**\n * Get all focusable elements inside `scope`,\n * discounting any that are ignored or inside an ignored container\n *\n * @param {HTMLElement|null} elem The element representing the search origin (currently focused element)\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getFocusables = (elem, scope) => {\n  if (!scope) return [];\n  /**\n   * Get all elements (within scope) that:\n   *  have a tabindex -> remove .lrud-ignore and children ->\n   *  filter all with tabindex=-1 unless .lrud-container ->\n   *  filter all .lrud-container with focus inside (could be nested containers) ->\n   *  filter all children of .lrud-container with data-autofocus=\"true\" OR data-destinations=[...]\n   */\n\n  const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n  let focusables = toArray(scope.querySelectorAll(focusableSelector))\n    .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n    .filter(node => matches(node, containerSelector) || parseInt(node.getAttribute('tabindex') || '-1', 10) > -1);\n\n  if (elem) {\n    // To remove containers that have focus inside them\n    focusables = focusables?.filter(node => !(matches(node, containerSelector) && node.contains(elem) ? false : true));\n  }\n\n  // Create a set of children to ignore from containers with data-autofocus=\"true\" or data-destinations\n  let childrenToIgnore = new Set();\n  focusables?.forEach(node => {\n    if (matches(node, containerSelector)) {\n      const hasAutoFocus = node.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n      const hasDestinations = node.getAttribute(DESTINATIONS_ATTRIBUTE)?.length > 0;\n      if (hasAutoFocus || hasDestinations) {\n        // add all children to ignore set irrespective of depth and focusability\n        const allChildren = toArray(node.querySelectorAll('*'));\n        allChildren.forEach(child => childrenToIgnore.add(child));\n      }\n    }\n  });\n\n  // Finally filter out all children that are in the ignore set\n  if (childrenToIgnore.size > 0) {\n    focusables = focusables?.filter(node => !childrenToIgnore.has(node));\n  }\n  return focusables;\n};\n\n/**\n * Get first focusable element as a default focus inside a 'scope'\n *\n * @param {HTMLElement} scope The element to search inside of\n * @param {String} exitDir The direction we exited from the starting element\n * @return {{elem: HTMLElement|null, parentHasAutofocus: boolean}} First focusable HTML Element\n */\nconst getDefaultFocus = (scope, exitDir) => {\n  let nextFocus = {elem: null, parentHasAutofocus: false};\n  const candidates = getAllFocusables(null, scope);\n  if (candidates.length > 0) {\n    let candidate = candidates[0];\n    // First candiate may be a container with autofocus or destinations\n    const candidateIsContainer = matches(candidate, containerSelector);\n    if (candidateIsContainer) {\n       nextFocus = findDestinationOrAutofocus(null, exitDir, candidate);\n    } else {\n      nextFocus = { elem: candidate, parentHasAutofocus: false };\n    }\n  }\n  return nextFocus;\n};\n\n/**\n * Get all the focusable candidates inside `scope`,\n * including focusable containers\n *\n * @param {HTMLElement|null} elem The element representing the search origin (currently focused element)\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getAllFocusables = (elem, scope) =>\n  // const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n    [\n    // ...toArray(scope.querySelectorAll(focusableContainerSelector))\n      // .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n      // .filter(container => getFocusables(container)?.length > 0),\n    ...getFocusables(elem, scope)\n  ];\n\n// /**\n//  * Build an array of ancestor containers\n//  *\n//  * @param {HTMLElement} initialContainer The container to start from\n//  * @return {HTMLElement[]} An array of ancestor containers\n//  */\n// const collectContainers = (initialContainer) => {\n//   if (!initialContainer) return [];\n//   const acc = [ initialContainer ];\n//   let cur = initialContainer;\n//   while (cur) {\n//     cur = getParentContainer(cur);\n//     if (cur) acc.push(cur);\n//   }\n//   return acc;\n// };\n\n/**\n * Get the middle point of a given edge\n *\n * @param {Object} rect An object representing the rectangle\n * @param {String} dir The direction of the edge (left, right, up, down)\n * @return {Point} An object with the X and Y coordinates of the point\n */\nconst getMidpointForEdge = (rect, dir) => {\n  switch (dir) {\n    case 'left':\n      return { x: rect.left, y: (rect.top + rect.bottom) / 2 };\n    case 'right':\n      return { x: rect.right, y: (rect.top + rect.bottom) / 2 };\n    case 'up':\n      return { x: (rect.left + rect.right) / 2, y: rect.top };\n    case 'down':\n      return { x: (rect.left + rect.right) / 2, y: rect.bottom };\n  }\n};\n\n/**\n * Gets the nearest point on `rect` that a line in direction `dir` from `point` would hit\n * If the rect is exactly in direction `dir` then the point will be in a straight line from `point`.\n * Otherwise it will be the nearest corner of the target rect.\n *\n * @param {Point} point The point to start from\n * @param {String} dir The direction to draw the line in\n * @param {Object} rect An object representing the rectangle of the item we're going to\n * @return {Point} An object with the X/Y coordinates of the nearest point\n */\nconst getNearestPoint = (point, dir, rect) => {\n  if (dir === 'left' || dir === 'right') {\n    // When moving horizontally...\n    // The nearest X is always the nearest edge, left or right\n    const x = dir === 'left' ? rect.right : rect.left;\n\n    // If the start point is higher than the rect, nearest Y is the top corner\n    if (point.y < rect.top) return { x, y: rect.top };\n    // If the start point is lower than the rect, nearest Y is the bottom corner\n    if (point.y > rect.bottom) return { x, y: rect.bottom };\n    // Else the nearest Y is aligned with where we started\n    return { x, y: point.y };\n  } else if (dir === 'up' || dir === 'down') {\n    // When moving vertically...\n    // The nearest Y is always the nearest edge, top or bottom\n    const y = dir === 'up' ? rect.bottom : rect.top;\n\n    // If the start point is left-er than the rect, nearest X is the left corner\n    if (point.x < rect.left) return { x: rect.left, y };\n    // If the start point is right-er than the rect, nearest X is the right corner\n    if (point.x > rect.right) return { x: rect.right, y };\n    // Else the nearest X is aligned with where we started\n    return { x: point.x, y };\n  }\n};\n\n/**\n * Get the Pythagorean distance between two points\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {number} Distance from A to B\n */\nconst getDistanceBetweenPoints = (a, b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n\n/**\n * Check if point A is below point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is below b, false otherwise\n */\nconst isBelow = (a, b) => a.y > b.y;\n\n/**\n * Check if point A is to the right of point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is to the right of b, false otherwise\n */\nconst isRight = (a, b) => a.x > b.x;\n\n// /**\n//  * Get blocked exit directions for current node\n//  *\n//  * @param {HTMLElement} originContainer Current focus container\n//  * @param {HTMLElement} candidateContainer Candidate focus container\n//  * @return {string[]} Array of strings representing blocked directions\n//  */\n// const getBlockedExitDirs = (originContainer, candidateContainer) => {\n//   if (!originContainer) {\n//     return [];\n//   }\n\n//   const currentAncestorContainers = collectContainers(originContainer);\n//   const candidateAncestorContainers = collectContainers(candidateContainer);\n\n//   // Find common container for current container and candidate container and\n//   // remove everything above it\n//   for (let i = 0; i < candidateAncestorContainers.length; i++) {\n//     let commonCandidate = candidateAncestorContainers[i];\n\n//     const spliceIndex = currentAncestorContainers.indexOf(commonCandidate);\n\n//     if (spliceIndex > -1) {\n//       currentAncestorContainers.splice(spliceIndex);\n//       break;\n//     }\n//   }\n\n//   return currentAncestorContainers.reduce((acc, cur) => {\n//     const dirs = (cur?.getAttribute(DATA_BLOCK_EXIT_ATTRIBUTE) || '').split(' ');\n\n//     return acc.concat(dirs);\n//   }, []);\n// };\n\n/**\n * Check if the candidate is in the `exitDir` direction from the rect we're leaving,\n * with an overlap allowance of entryWeighting as a percentage of the candidate's width.\n *\n * @param {Object} entryRect An object representing the rectangle of the item we're moving to\n * @param {String} exitDir The direction we're moving in\n * @param {Object} exitPoint The midpoint of the edge we're leaving\n * @param {Float} entryWeighting Percentage of the candidate that is allowed to be behind the target\n * @return {Booelan} true if candidate is in the correct dir, false if not\n */\nconst isValidCandidate = (entryRect, exitDir, exitPoint, entryWeighting) => {\n  if (entryRect.width === 0 && entryRect.height === 0) return false;\n  if (!entryWeighting && entryWeighting != 0) entryWeighting = 0.3;\n\n  const weightedEntryPoint = {\n    x: entryRect.left + (entryRect.width * (exitDir === 'left' ? 1 - entryWeighting : exitDir === 'right' ? entryWeighting : 0.5)),\n    y: entryRect.top + (entryRect.height * (exitDir === 'up' ? 1 - entryWeighting : exitDir === 'down' ? entryWeighting : 0.5))\n  };\n\n  if (\n    exitDir === 'left' && isRight(exitPoint, weightedEntryPoint) ||\n    exitDir === 'right' && isRight(weightedEntryPoint, exitPoint) ||\n    exitDir === 'up' && isBelow(exitPoint, weightedEntryPoint) ||\n    exitDir === 'down' && isBelow(weightedEntryPoint, exitPoint)\n  ) return true;\n\n  return false;\n};\n\n/**\n * Sort the candidates ordered by distance to the elem,\n * and filter out invalid candidates.\n *\n * @param {HTMLElement[]} candidates A set of candidate elements to sort\n * @param {HTMLElement} elem The search origin\n * @param {string} exitDir The direction in which we exited the elem (left, right, up, down)\n * @return {HTMLElement[]} The valid candidates, in order by distance\n */\nconst sortValidCandidates = (candidates, elem, exitDir) => {\n  const exitRect = elem?.getBoundingClientRect() || { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0 }; // For default case\n  const exitPoint = getMidpointForEdge(exitRect, exitDir);\n  return candidates.filter(candidate => {\n    // Filter out candidates that are in the opposite direction or have no dimensions\n    const entryRect = candidate.getBoundingClientRect();\n    const allowedOverlap = parseFloat(candidate.getAttribute('data-lrud-overlap-threshold'));\n    return isValidCandidate(entryRect, exitDir, exitPoint, allowedOverlap);\n  }).map(candidate => {\n    const entryRect = candidate.getBoundingClientRect();\n    const nearestPoint = getNearestPoint(exitPoint, exitDir, entryRect);\n    const distance = getDistanceBetweenPoints(exitPoint, nearestPoint);\n    return {\n      candidate,\n      distance\n    };\n  }).sort((a, b) => a.distance - b.distance).map(({ candidate }) => candidate);\n};\n\n/**\n * Get the first parent container that matches the focusable candidate selector\n * @param {HTMLElement} startingCandidate The starting candidate to get the parent container of\n * @return {HTMLElement} The container that matches or null\n */\n// const getParentFocusableContainer = (startingCandidate) => {\n//   if (!startingCandidate) return null;\n//   do {\n//     startingCandidate = getParentContainer(startingCandidate);\n//   } while (startingCandidate && !matches(startingCandidate, focusableContainerSelector));\n\n//   return startingCandidate;\n// };\n\n/**\n * Get a possible destination (if set) for a container\n * @param {HTMLElement} parentContainer The parent container\n * @return {HTMLElement | null | -1} The element that should get the focus next, (null if nothing to focus, undefined if no destinations available)\n */\nconst getPreferredDestination = (parentContainer) => {\n  // Use destinations if available to find new focus\n  const destinations = parentContainer?.getAttribute(DESTINATIONS_ATTRIBUTE);\n  if (destinations?.length) {\n    // Find the first valid element and set that as newFocus\n    const candidateIDs = destinations.split(' ');\n    let newFocus = null;\n    for (let candidateID of candidateIDs) {\n      newFocus = document.getElementById(candidateID);\n      if (newFocus) {\n        break;\n      }\n    }\n    return newFocus;\n  } else {\n    return undefined;\n  }\n};\n\n/**\n * Run autofocus logic to find next focus\n *\n * @param {HTMLElement} elem The starting element\n * @param {string} exitDir The direction exited from the starting element\n * @param {HTMLElement} candidateContainer Container on which autofocus logic needs run\n * @return {{elem: HTMLElement|null, parentHasAutofocus: boolean}  } Next focus element in container\n */\nconst findDestinationOrAutofocus = (elem, exitDir, candidateContainer) => {\n  const hasAutoFocus = candidateContainer?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n  // 1. Use destinations (if available) to find new focus\n  const destination = getPreferredDestination(candidateContainer);\n  if (destination !== undefined && destination !== null) {\n      return { elem: destination, parentHasAutofocus: hasAutoFocus };\n  }\n  // Use last known active child or first focusable child\n  if (hasAutoFocus) {\n    let newFocus = document.getElementById(candidateContainer?.getAttribute(DATA_FOCUS_ATTRIBUTE));\n    if (newFocus) {\n      return { elem: newFocus, parentHasAutofocus: hasAutoFocus };\n    }\n    // Get first focusable child\n    // This is not exactly the first focusable child in DOM order (based on experiments on Android TV),\n    // but the first focusable child as per LRUD logic\n    const candidateContainerFocusables = getFocusables(null, candidateContainer);\n    newFocus = sortValidCandidates(candidateContainerFocusables, elem, exitDir)?.[0];\n    // Container may be empty or another Container. No further processing into child containers required\n    return { elem: newFocus, parentHasAutofocus: hasAutoFocus };\n  }\n\n  return { elem: null, parentHasAutofocus: hasAutoFocus };\n};\n\n/**\n * Get one from the possible focusable candidates\n *\n * @param {HTMLElement[]} focusableCandidates Possible candidates list to choose from\n * @param {HTMLElement} elem The search origin (currently focused element)\n * @param {string} exitDir Direction requested\n * @return {{elem: HTMLElement|null, parentHasAutofocus: boolean}} candidate that gets the next focus or null if nothing valid found\n */\n\nconst getNextFromCandidates = (focusableCandidates, elem, exitDir) => {\n  /**\n   * The Candidates are already sorted by distance and filtered for valid direction\n   * Now we need to check each candidate for:\n   *  - if blockExits are available for current container and match the exitDir\n   *    - if candidate is a not a container\n   *      - if parent container of candidate and current container are same -> return candidate\n   *      - else return null as exit is blocked\n   *    - if candidate is a container\n   *      - we've hit a block exit as we are trying to exit current container\n   *      - return null as exit is blocked\n   *  - if block exit is false\n   *    - if candidate is a container\n   *      - run autofocus logic on container to find next focus\n   *    - if candidate is not a container\n   *     - return candidate as is\n   */\n  let nextFocus = { elem: null, parentHasAutofocus: false };\n  const originContainer = getParentContainer(elem);\n  const blockExits = originContainer?.getAttribute(DATA_BLOCK_EXIT_ATTRIBUTE);\n  const allowBlockExits = !(blockExits && blockExits.length > 0 && blockExits.split(' ').includes(exitDir));\n\n  for (const candidate of focusableCandidates) {\n    const candidateIsContainer = matches(candidate, containerSelector);\n    if (!allowBlockExits) {\n      if (!candidateIsContainer) {\n        const candidatesContainer = getParentContainer(candidate);\n        if (candidatesContainer === originContainer) {\n          // Candidate is in the same container as current focus\n          const parentHasAutofocus = candidatesContainer?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n          return { elem: candidate, parentHasAutofocus };\n        }\n      }\n      // Trying to enter a different container, exit is blocked, return null\n      return { elem: null, parentHasAutofocus: false };\n    }\n\n    if (candidateIsContainer) {\n      // Found a tvFocusable container, run the autofocus logic\n      nextFocus = findDestinationOrAutofocus(elem, exitDir, candidate);\n      return nextFocus;\n    } else {\n      // If the candidate is not a container, we can return it as is\n      const parentHasAutofocus = getParentContainer(candidate)?.getAttribute(DATA_AUTOFOCUS_ATTRIBUTE) === 'true';\n      nextFocus = { elem: candidate, parentHasAutofocus };\n    }\n  }\n  // If here, nothing could be found\n  return nextFocus;\n};\n\n/**\n * Get the next focus candidate\n *\n * @param {HTMLElement} elem The search origin (currently focused element)\n * @param {string|number} keyOrKeyCode The key or keyCode value (from KeyboardEvent) of the pressed key\n * @param {HTMLElement} scope The element LRUD spatial is scoped to operate within\n * @return {{elem: HTMLElement, parentHasAutofocus: boolean}} The element that should receive focus next\n */\nexport const getNextFocus = (elem, keyOrKeyCode, scope) => {\n  /**\n   * If no scope provided, use document body\n   * If no elem provided, find a default focus inside scope\n   *\n   * Get all candidates inside scope (focusable and with container collapse/expand logic)\n   * Sort and filter candidates based on direction and distance\n   * Find next focus from candidates\n   * If still not found, return null\n   */\n  const exitDir = _keyMap[keyOrKeyCode];\n  if (!scope || !scope.querySelector) scope = document.body;\n  if (!elem) return getDefaultFocus(scope, exitDir);\n\n  let nextFocus = null;\n\n  let candidates = [];\n  const focusables = getAllFocusables(elem, scope);\n  candidates = sortValidCandidates(focusables, elem, exitDir);\n  nextFocus = getNextFromCandidates(candidates, elem, exitDir);\n  return nextFocus;\n};"],"mappings":"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","ignoreList":[]}