{"version":3,"file":"lrud.min.js","names":["focusableSelector","containerSelector","ignoreSelector","DESTINATIONS_ATTRIBUTE","_left","_right","_up","_down","_keyMap","createMissingId","setConfig","exports","config","keyMap","_typeof","Function","createMissingIdCallback","getId","element","_element$id","id","length","matches","selectors","console","warn","fn","Element","prototype","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","s","document","ownerDocument","querySelectorAll","i","item","call","toArray","nodeList","Array","slice","getParentContainer","elem","parentElement","tagName","getFocusables","scope","ignoredElements","filter","node","some","ignored","contains","className","includes","parseInt","getAttribute","getAllFocusables","concat","collectContainers","initialContainer","acc","cur","push","getMidpointForEdge","rect","dir","x","left","y","top","bottom","right","getNearestPoint","point","getDistanceBetweenPoints","a","b","Math","sqrt","pow","isBelow","isRight","getBlockedExitDirs","container","candidateContainer","currentAncestorContainers","candidateAncestorContainers","commonCandidate","spliceIndex","indexOf","splice","reduce","dirs","split","isValidCandidate","entryRect","exitDir","exitPoint","entryWeighting","width","height","weightedEntryPoint","sortValidCandidates","candidates","exitRect","getBoundingClientRect","candidate","allowedOverlap","parseFloat","map","nearestPoint","distance","sort","_ref","getPreferredDestination","parentContainer","destinations","candidateIDs","newFocus","_iterator","_createForOfIteratorHelper","_step","n","done","candidateID","value","getElementById","err","e","f","undefined","getNextFocus","keyOrKeyCode","_getFocusables","querySelector","body","setAttribute","focusableCandidates","focusableSiblings","_iterator2","_step2","candidateIsContainer","isCurrentContainer","isNestedContainer","isAnscestorContainer","blockedExitDirs","_getFocusables2","destination","lastActiveChild"],"sources":["lrud.js"],"sourcesContent":["/**\n * LRUD: Spatial Edition\n *\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *  @@@@@@      '@@@@@@@@@   @@@@@@      '@@@@@@@@@   @@@@@@@@      '@@@@@@@\n *  @@@@@@  @@.   @@@@@@@@   @@@@@@  @@.    @@@@@@@   @@@@@     @@@@.   @@@@\n *  @@@@@@  @@@@  @@@@@@@@   @@@@@@  @@@@   @@@@@@@   @@@@   @@@@@@@@@@@@@@@\n *  @@@@@@        @@@@@@@@   @@@@@@        @@@@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@.  @@@@@@   @@@@@@  @@@@@.  @@@@@@   @@@   @@@@@@@@@@@@@@@@\n *  @@@@@@  @@@@@   @@@@@@   @@@@@@  @@@@@   @@@@@@   @@@@    @@@@@@@@/ @@@@\n *  @@@@@@        /@@@@@@@   @@@@@@        /@@@@@@@   @@@@@@\\,         @@@@@\n *  @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@\n *\n * Copyright (C) 2023 BBC.\n */\n\n// Any \"interactive content\" https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Interactive_content\nconst focusableSelector = '[tabindex], a, input, button';\nconst containerSelector = 'nav, section, .lrud-container'; // TODO: Do we need nav and selection here anymore??\n// const focusableContainerSelector = '[data-lrud-consider-container-distance]'; // Manage using just the containerSelector\nconst ignoreSelector = '.lrud-ignore, [disabled]';\nconst DESTINATIONS_ATTRIBUTE = 'data-destinations';\n\n/**\n * This is how the React Native Web TV props are mapped here:\n *\n * 1. TVFocusGuideView.tvFocusable={true}  -> .lrud-container\n * 2. TVFocusGuideView.focusable={false} -> set .lrud-ignore\n * 3. TVFocusGuideView.autoFocus={true} -> TODO: data-autofocus attribute is to 'true'/'false'. The attributes data-destinations and\n *    data-focus parent containers should only be applied when data-focus is true. Same for data-block-exit??\n * 4. TVFocusGuideView.trapFocusUp={true} -> data-block-exit=\"up\"\n * 5. TVFocusGuideView.trapFocusDown={true} -> data-block-exit=\"down\"\n * 6. TVFocusGuideView.trapFocusLeft={true} -> data-block-exit=\"left\"\n * 7. TVFocusGuideView.trapFocusRight={true} -> data-block-exit=\"right\"\n * 8. TVFocusGuideView.destinations=[\"id1\", \"id2\"] -> data-destinations=\"id1 id2\": These ids are from\n *    id assigned to each of the destination elements.\n *\n * Any other compoenents are navigated using the default lrud algorithm based on tabindex and role of elements.\n */\n\nconst _left = 'left', _right = 'right', _up = 'up', _down = 'down';\nlet _keyMap = {\n  4: _left,\n  21: _left,\n  37: _left,\n  214: _left,\n  205: _left,\n  218: _left,\n  5: _right,\n  22: _right,\n  39: _right,\n  213: _right,\n  206: _right,\n  217: _right,\n  29460: _up,\n  19: _up,\n  38: _up,\n  211: _up,\n  203: _up,\n  215: _up,\n  29461: _down,\n  20: _down,\n  40: _down,\n  212: _down,\n  204: _down,\n  216: _down,\n  'ArrowLeft': _left,\n  'ArrowRight': _right,\n  'ArrowUp': _up,\n  'ArrowDown': _down\n};\n\nlet createMissingId = null;\n\nexport const setConfig = (config) => {\n  _keyMap = config.keyMap || _keyMap;\n  createMissingId = typeof config.createMissingId === Function ? config.createMissingIdCallback : null;\n};\n\nconst getId = (element) => {\n (element.id && element.id?.length) ? element.id : createMissingId ? createMissingId(element) : '';\n};\n\n/**\n * Element API .matches() with fallbacks\n */\nconst matches = (element, selectors) => {\n  if (!element) {\n    console.warn('matches() passed with a null element');\n    return false;\n  }\n  const fn = Element.prototype.matches ||\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector ||\n    function(s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n        i = matches.length;\n      // eslint-disable-next-line no-empty\n      while (--i >= 0 && matches.item(i) !== this) {}\n      return i > -1;\n    };\n\n  return fn.call(element, selectors);\n};\n\n/**\n * Convert a NodeList to a regular Array\n *\n * @param {NodeList} nodeList The NodeList representation\n * @return {Array|null} The Array representation\n */\nconst toArray = (nodeList) => Array.prototype.slice.call(nodeList);\n\n/**\n * Traverse DOM ancestors until we find a focus container\n *\n * @param {HTMLElement} elem The element representing the search origin\n * @return {HTMLElement|null} The parent focus container or null\n */\nconst getParentContainer = (elem) => {\n  if (!elem.parentElement || elem.parentElement.tagName === 'BODY') {\n    return null;\n  } else if (matches(elem.parentElement, containerSelector)) {\n    return elem.parentElement;\n  }\n\n  return getParentContainer(elem.parentElement);\n};\n\n/**\n * Get all focusable elements inside `scope`,\n * discounting any that are ignored or inside an ignored container\n *\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getFocusables = (scope) => {\n  if (!scope) return [];\n\n  const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n  return toArray(scope.querySelectorAll(focusableSelector))\n    .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n    .filter(node => node.className.includes('lrud-container') || parseInt(node.getAttribute('tabindex') || '0', 10) > -1);\n};\n\n/**\n * Get all the focusable candidates inside `scope`,\n * including focusable containers\n *\n * @param {HTMLElement} scope The element to search inside of\n * @return {HTMLElement[]} Array of valid focusables inside the scope\n */\nconst getAllFocusables = (scope) =>\n  // const ignoredElements = toArray(scope.querySelectorAll(ignoreSelector));\n\n    [\n    // ...toArray(scope.querySelectorAll(focusableContainerSelector))\n      // .filter(node => !ignoredElements.some(ignored => ignored == node || ignored.contains(node)))\n      // .filter(container => getFocusables(container)?.length > 0),\n    ...getFocusables(scope)\n  ];\n\n/**\n * Build an array of ancestor containers\n *\n * @param {HTMLElement} initialContainer The container to start from\n * @return {HTMLElement[]} An array of ancestor containers\n */\nconst collectContainers = (initialContainer) => {\n  if (!initialContainer) return [];\n  const acc = [ initialContainer ];\n  let cur = initialContainer;\n  while (cur) {\n    cur = getParentContainer(cur);\n    if (cur) acc.push(cur);\n  }\n  return acc;\n};\n\n/**\n * Get the middle point of a given edge\n *\n * @param {Object} rect An object representing the rectangle\n * @param {String} dir The direction of the edge (left, right, up, down)\n * @return {Point} An object with the X and Y coordinates of the point\n */\nconst getMidpointForEdge = (rect, dir) => {\n  switch (dir) {\n    case 'left':\n      return { x: rect.left, y: (rect.top + rect.bottom) / 2 };\n    case 'right':\n      return { x: rect.right, y: (rect.top + rect.bottom) / 2 };\n    case 'up':\n      return { x: (rect.left + rect.right) / 2, y: rect.top };\n    case 'down':\n      return { x: (rect.left + rect.right) / 2, y: rect.bottom };\n  }\n};\n\n/**\n * Gets the nearest point on `rect` that a line in direction `dir` from `point` would hit\n * If the rect is exactly in direction `dir` then the point will be in a straight line from `point`.\n * Otherwise it will be the nearest corner of the target rect.\n *\n * @param {Point} point The point to start from\n * @param {String} dir The direction to draw the line in\n * @param {Object} rect An object representing the rectangle of the item we're going to\n * @return {Point} An object with the X/Y coordinates of the nearest point\n */\nconst getNearestPoint = (point, dir, rect) => {\n  if (dir === 'left' || dir === 'right') {\n    // When moving horizontally...\n    // The nearest X is always the nearest edge, left or right\n    const x = dir === 'left' ? rect.right : rect.left;\n\n    // If the start point is higher than the rect, nearest Y is the top corner\n    if (point.y < rect.top) return { x, y: rect.top };\n    // If the start point is lower than the rect, nearest Y is the bottom corner\n    if (point.y > rect.bottom) return { x, y: rect.bottom };\n    // Else the nearest Y is aligned with where we started\n    return { x, y: point.y };\n  } else if (dir === 'up' || dir === 'down') {\n    // When moving vertically...\n    // The nearest Y is always the nearest edge, top or bottom\n    const y = dir === 'up' ? rect.bottom : rect.top;\n\n    // If the start point is left-er than the rect, nearest X is the left corner\n    if (point.x < rect.left) return { x: rect.left, y };\n    // If the start point is right-er than the rect, nearest X is the right corner\n    if (point.x > rect.right) return { x: rect.right, y };\n    // Else the nearest X is aligned with where we started\n    return { x: point.x, y };\n  }\n};\n\n/**\n * Get the Pythagorean distance between two points\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {number} Distance from A to B\n */\nconst getDistanceBetweenPoints = (a, b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n\n/**\n * Check if point A is below point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is below b, false otherwise\n */\nconst isBelow = (a, b) => a.y > b.y;\n\n/**\n * Check if point A is to the right of point B\n *\n * @param {Point} a An object containing the X and Y coordinates of the point\n * @param {Point} b Point to compare\n * @return {boolean} True if a is to the right of b, false otherwise\n */\nconst isRight = (a, b) => a.x > b.x;\n\n/**\n * Get blocked exit directions for current node\n *\n * @param {HTMLElement} container Current focus container\n * @param {HTMLElement} candidateContainer Candidate focus container\n * @return {string[]} Array of strings representing blocked directions\n */\nconst getBlockedExitDirs = (container, candidateContainer) => {\n  if (!container) {\n    return [];\n  }\n\n  const currentAncestorContainers = collectContainers(container);\n  const candidateAncestorContainers = collectContainers(candidateContainer);\n\n  // Find common container for current container and candidate container and\n  // remove everything above it\n  for (let i = 0; i < candidateAncestorContainers.length; i++) {\n    let commonCandidate = candidateAncestorContainers[i];\n\n    const spliceIndex = currentAncestorContainers.indexOf(commonCandidate);\n\n    if (spliceIndex > -1) {\n      currentAncestorContainers.splice(spliceIndex);\n      break;\n    }\n  }\n\n  return currentAncestorContainers.reduce((acc, cur) => {\n    const dirs = (cur?.getAttribute('data-block-exit') || '').split(' ');\n\n    return acc.concat(dirs);\n  }, []);\n};\n\n/**\n * Check if the candidate is in the `exitDir` direction from the rect we're leaving,\n * with an overlap allowance of entryWeighting as a percentage of the candidate's width.\n *\n * @param {Object} entryRect An object representing the rectangle of the item we're moving to\n * @param {String} exitDir The direction we're moving in\n * @param {Object} exitPoint The midpoint of the edge we're leaving\n * @param {Float} entryWeighting Percentage of the candidate that is allowed to be behind the target\n * @return {Booelan} true if candidate is in the correct dir, false if not\n */\nconst isValidCandidate = (entryRect, exitDir, exitPoint, entryWeighting) => {\n  if (entryRect.width === 0 && entryRect.height === 0) return false;\n  if (!entryWeighting && entryWeighting != 0) entryWeighting = 0.3;\n\n  const weightedEntryPoint = {\n    x: entryRect.left + (entryRect.width * (exitDir === 'left' ? 1 - entryWeighting : exitDir === 'right' ? entryWeighting : 0.5)),\n    y: entryRect.top + (entryRect.height * (exitDir === 'up' ? 1 - entryWeighting : exitDir === 'down' ? entryWeighting : 0.5))\n  };\n\n  if (\n    exitDir === 'left' && isRight(exitPoint, weightedEntryPoint) ||\n    exitDir === 'right' && isRight(weightedEntryPoint, exitPoint) ||\n    exitDir === 'up' && isBelow(exitPoint, weightedEntryPoint) ||\n    exitDir === 'down' && isBelow(weightedEntryPoint, exitPoint)\n  ) return true;\n\n  return false;\n};\n\n/**\n * Sort the candidates ordered by distance to the elem,\n * and filter out invalid candidates.\n *\n * @param {HTMLElement[]} candidates A set of candidate elements to sort\n * @param {HTMLElement} elem The search origin\n * @param {string} exitDir The direction in which we exited the elem (left, right, up, down)\n * @return {HTMLElement[]} The valid candidates, in order by distance\n */\nconst sortValidCandidates = (candidates, elem, exitDir) => {\n  const exitRect = elem.getBoundingClientRect();\n  const exitPoint = getMidpointForEdge(exitRect, exitDir);\n  return candidates.filter(candidate => {\n    // Filter out candidates that are in the opposite direction or have no dimensions\n    const entryRect = candidate.getBoundingClientRect();\n    const allowedOverlap = parseFloat(candidate.getAttribute('data-lrud-overlap-threshold'));\n    return isValidCandidate(entryRect, exitDir, exitPoint, allowedOverlap);\n  }).map(candidate => {\n    const entryRect = candidate.getBoundingClientRect();\n    const nearestPoint = getNearestPoint(exitPoint, exitDir, entryRect);\n    const distance = getDistanceBetweenPoints(exitPoint, nearestPoint);\n    return {\n      candidate,\n      distance\n    };\n  }).sort((a, b) => a.distance - b.distance).map(({ candidate }) => candidate);\n};\n\n/**\n * Get the first parent container that matches the focusable candidate selector\n * @param {HTMLElement} startingCandidate The starting candidate to get the parent container of\n * @return {HTMLElement} The container that matches or null\n */\n// const getParentFocusableContainer = (startingCandidate) => {\n//   if (!startingCandidate) return null;\n//   do {\n//     startingCandidate = getParentContainer(startingCandidate);\n//   } while (startingCandidate && !matches(startingCandidate, focusableContainerSelector));\n\n//   return startingCandidate;\n// };\n\n/**\n * Get a possible destination (if set) for a container\n * @param {HTMLElement} parentContainer The parent container\n * @return {HTMLElement | null | -1} The element that should get the focus next, (null if nothing to focus, undefined if no destinations available)\n */\nconst getPreferredDestination = (parentContainer) => {\n  // Use destinations if available to find new focus\n  const destinations = parentContainer?.getAttribute(DESTINATIONS_ATTRIBUTE);\n  if (destinations?.length) {\n    // Find the first valid element and set that as newFocus\n    const candidateIDs = destinations.split(' ');\n    let newFocus = null;\n    for (let candidateID of candidateIDs) {\n      newFocus = document.getElementById(candidateID);\n      if (newFocus) {\n        break;\n      }\n    }\n    return newFocus;\n  } else {\n    return undefined;\n  }\n};\n\n/**\n * Get the next focus candidate\n *\n * @param {HTMLElement} elem The search origin\n * @param {string|number} keyOrKeyCode The key or keyCode value (from KeyboardEvent) of the pressed key\n * @param {HTMLElement} scope The element LRUD spatial is scoped to operate within\n * @return {HTMLElement} The element that should receive focus next\n */\nexport const getNextFocus = (elem, keyOrKeyCode, scope) => {\n  if (!scope || !scope.querySelector) scope = document.body;\n  if (!elem) return getFocusables(scope)?.[0];\n  const exitDir = _keyMap[keyOrKeyCode];\n\n  // Get parent focus container\n  const parentContainer = getParentContainer(elem);\n  if (parentContainer && matches(elem, focusableSelector)) {\n    parentContainer.setAttribute('data-focus', getId(elem));\n    // getParentFocusableContainer(parentContainer)?.setAttribute('data-focus', elem.id);\n  }\n\n  let focusableCandidates = [];\n\n  // Get all siblings within a prioritised container\n  if (parentContainer?.getAttribute('data-lrud-prioritise-children') !== 'false' && scope.contains(parentContainer)) {\n    const focusableSiblings = getAllFocusables(parentContainer);\n    focusableCandidates = sortValidCandidates(focusableSiblings, elem, exitDir);\n  }\n\n  if (focusableCandidates.length === 0) {\n    const candidates = getAllFocusables(scope);\n    focusableCandidates = sortValidCandidates(candidates, elem, exitDir);\n  }\n\n  for (const candidate of focusableCandidates) {\n    const candidateIsContainer = matches(candidate, containerSelector);\n    const candidateContainer = candidateIsContainer ? candidate : getParentContainer(candidate);\n\n    const isCurrentContainer = candidateContainer === parentContainer;\n    const isNestedContainer = parentContainer?.contains(candidateContainer);\n    const isAnscestorContainer = candidateContainer?.contains(parentContainer);\n\n    if (!isCurrentContainer && (!isNestedContainer || candidateIsContainer)) {\n      const blockedExitDirs = getBlockedExitDirs(parentContainer, candidateContainer);\n      if (blockedExitDirs.indexOf(exitDir) > -1) continue; // TODO: should we stop searching here?\n\n      if (candidateContainer && !isAnscestorContainer) {\n        if (candidateIsContainer) {\n          // Use destinations if available to find new focus\n          const destination = getPreferredDestination(candidateContainer);\n          if (destination !== undefined) {\n            if (destination !== null) {\n              candidateContainer?.setAttribute('data-focus', destination?.id);\n            }\n            // TODO: What if destination is a container!!\n            return destination;\n          }\n        }\n        // Ignore active child behaviour when moving into a container that we\n        // are already nested in\n        const lastActiveChild = document.getElementById(candidateContainer?.getAttribute('data-focus'));\n\n        const newFocus = lastActiveChild || getFocusables(candidateContainer)?.[0];\n        // Container may be empty or another Container\n        if (!newFocus || matches(newFocus, containerSelector)) {\n          continue;\n        }\n        // getParentFocusableContainer(candidateContainer)?.setAttribute('data-focus', newFocus?.id);\n\n        candidateContainer?.setAttribute('data-focus', getId(newFocus));\n        return newFocus;\n      }\n    }\n\n    if (!candidateIsContainer) {\n      // getParentFocusableContainer(candidateContainer)?.setAttribute('data-focus', candidate.id);\n      candidateContainer?.setAttribute('data-focus', getId(candidate));\n    }\n    return candidate;\n  }\n};"],"mappings":"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","ignoreList":[]}